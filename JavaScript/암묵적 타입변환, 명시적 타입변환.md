# 타입 변환이란?

자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다.
개발자가 의도적으로 값의 타입을 변환하는 것을 `명시적 타입 변환` 또는 `타입 캐스팅`이라 한다.

```javascript
var x = 10;

// 명시적 타입 변환
// 숫자를 문자열로 타입 캐스팅한다. 
var str = x.toString();
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아니다.
console.log(typeof x, x);
```

<br>

개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 `암묵적 타입 변환` 또는 `타입 강제 변환`이라 한다.


```javascript
var x = 10;

// 암묵적 타입 변환
// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다. 
var str = x + '';
console.log(typeof str, str);  // string 10

// x 변수의 값이 변경된 것은 아니다.
console.log(typeof x, x);      // number 10
```

`명시적 타입 변환`이나 `암묵적 타입 변환`이 기존 원시 값을 직접 변경하는 것은 아니다. 원시 값은 `변경 불가능한 값(immutable value)`이므로 변경할 수 없다. 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.

<br>

위 예제의 경우 자바스크립트 엔진은 표현식 `x + ''`을 평가하기 위해 x 변수의 숫자 값을 바탕으로 새로운 문자열 값 '10'을 생성하고 이것으로 표현식 `'10' + ''`를 계산한다. 이때 암묵적으로 생성된 문자열 '10'은 x변수에 재할당되지 않는다. 따라서 암묵적으로 생성된 문자열 '10'은 표현식의 평가가 끝나면 아무도 참조하지 않으므로 가비지 컬렉터에 의해 메모리에서 해제된다.

<br>

즉, 암묵적 타입 변환은 기존 변수 값을 재할당하여 변경하는 것이 아니다. 자바스크립트 엔진은 표현식을 에러 없이 평가하기 위해 피연산자의 값을 `암묵적 타입 변환`해 새로운 타입의 값을 만들어 단 한 번 사용하고 버린다.

<br>

`명시적 타입 변환`은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다.

<br>

## 암묵적 타입 변환

자바스크립트 엔진은 표현식을 평가할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환(`암묵적 타입 변환`)할 때가 있다.

```javascript
// 피연산자가 모두 문자열 타입이어야 하는 문맥
'10' + 2   // '102'

// 피연산자가 모두 숫자 타입이어야 하는 문백
5 * '10'   // 50  (조금 의외군?)

// 피연산자 또는 표현식이 불리언 타입이어야 하는 문맥
!0  // true
```

이처럼 표현식을 평가할 때 코드의 문백에 부합하지 않는 많은 상황이 존재할 수 있다. 이 때 다른 프로그래밍 언어는 에러를 발생시키는 것도 있지만, `자바스크립트`는 가급적 에러를 발생시키지 않도록 `암묵적 타입 변환`을 통해 표현식을 처리한다.

<br>

## 문자열 타입으로 변환

```javascript
// 숫자 타입
0 + ''     // "0"
-0 + ''    // "0"
1 + ''     // "1"

// 불리언 타입
true + ''  // "true"
false + '' // "false"

// null 타입
null + ''  // "null"

// undefined 타입
undefined + '' // undefined
```

<br>

## 숫자 타입으로 변환

```javascript
// 문자열 타입
+''        // 0
+'0'       // 0
+'1'       // 1
+'string'  // NaN

// 불리언 타입
+true     // 1
+false    // 0

// null 타입
+null     // 0

// undefined 타입
+undefined // NaN
```

<br>

## 명시적 타입 변환

개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다. 표준 빌트인 생성자 함수(`String, Number, Boolean`)를 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 위에서 본 `암묵적 타입 변환`을 이용하는 방법이 있다.

<br>

## 문자열 타입으로 변환

문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과 같다.

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메소드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

```javascript
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
// 숫자 타입 => 문자열 타입
String(1);      // "1"
String(Nan);    // "NaN"

// 불리언 타입 => 문자열 타입
String(true);   // "true"
String(false);  // "false"

// 2. Object.prototype.toString 메소드를 사용하는 방법
(1).toString();    // "1"
(NaN).toString();  // "NaN"

// 불리언 타입 => 문자열 타입
(true).toString();   // "true"
(false).toString();  // "false"
```

<br>

## 숫자 타입으로 변환

숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 다음과 같다.

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
- 단항 산술 연산자 + 이용하기
- 산술 연산자 *를 이용하기

```javascript
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0');     // 0
Number('-1');    // -1
Number('10.53'); // 10.53

// 불리언 타입 => 숫자 타입
Number(true);   // 1
Number(false);  // 0

// 2. parseInt, parseFloat 함수를 사용하는 방법
// 문자열 타입 => 숫자 타입
parseInt('0');        // 0
parseInt('-1');       // -1
parseFloat('10.53');  // 10.53
```

<br>

## 구조 분해 할당

`구조 분해 할당` 구문은 배열이나 객체의 속성을 해체하여 구 값을 개별 변수에 담을 수 있게 하는 javaScript 표현식이다.

```javascript
let a, b, rest;
[a, b] = [10, 20];

console.log(a);  // 10
console.log(b);  // 20
```

<br>

### 중간 내용 무시하기

```javascript
[a, , b] = [1, 2, 3];

console.log(a);  // 1
console.log(b);  // 3
```

<br>

### 변수에 배열의 나머지를 할당하기

```javascript
[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(a);      // 10
console.log(b);      // 20
console.log(rest);   // [ 30, 40, 50 ]
```

<br>

## 객체 구조 분해

```javascript
var o = { p: 42, q: true };
var { p, q } = o;

console.log(p); // 42
console.log(q); // true
```




