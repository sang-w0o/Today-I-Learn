# `2장: 코틀린의 기초`

2장에서 다루는 내용

- 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법

- 제어 구조

- 스마트 캐스트

- 예외 던지기와 예외 잡기

<br> <br>

## `2.1.2 함수`

```kotlin
fun max (a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

- 함수를 선언할 때 `fun` 키워드를 사용합니다.

- 파라미터 이름 뒤에 그 파라미터 타입을 적습니다.

- 함수를 최상위 수준에 정의할 수 있습니다. 자바와 달리 꼭 클래스 안에 함수를 넣어야 할 필요가 없습니다.

- 배열도 일반적인 클래스와 마찬가지입니다. 코틀린에는 자바와 달라 배열 처리를 위한 문법이 따로 존재하지 않습니다.

<br>

```kotlin
fun max (a: Int, b: Int): Int = if (a > b) a else b
```

처음에 보았던 코드를 간략하게 줄이면 위와 같이 줄일 수 있습니다. 코틀린에서는 `식이 본문인 함수가 자주 사용됩니다.`

<br>

```kotlin
fun max (a: Int, b: Int) = if (a > b) a else b
```

위와 같이 반환 타입도 생략할 수 있습니다. 

> 생략 가능한 이유는 코틀린은 정적 타입 지정 언어이므로 컴파일 시점에 모든 식의 타입을 지정해야 했지만, 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 결과 타입을 함수 변환 타입으로 정해줍니다.

이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 `타입 추론`이라 부릅니다. 식이 본문인 함수의 반환 티입만 생략 가능하다는 점을 알아야 합니다. 

<br> <br>

## `2.1.3 변수`

자바에서는 변수를 선언할 때 타입이 맨 앞에 오지만, 코틀린에서는 뒤에 선언합니다. 

```kotlin
val question = "String"
val answer = 42
```

그리고 위와 같이 `초기화할 값이 있다면 타입을 생략할 수 있습니다.`

<br>

### 변경 가능한 변수와 변경 불가능한 변수

- val(값을 뜻하는 value에서 따옴) - `변경 불가능한 참조를 저장하는 변수입니다.` 자바로 말하자면 final 변수로 해당합니다.

- var(변수를 뜻하는 variable에서 따옴) - `변경 가능한 참조입니다.` 자바의 일반 변수에 해당합니다.

<br> 

기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고 나중에 꼭 필요할 때에만 var로 변경하는 것이 좋습니다. 

<br> <br>

## `2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿`

```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!");
}
```

이 문자열 템플릿은 자바의 문자열 접합 연산 `("Hello, " + name + "!"`과 동일한 기능을 하지만 좀 더 간결하다는 장점이 있습니다.

<br> <br>

## `2.1.4 문자열 템플릿`

```kotlin
fun main() {
    val name = "Gyunny"
    println("Hello $name")
}
```

문자열 템플릿을 사용해서 쉽게 변수를 출력할 수 있습니다. 

<br> <br>

## `2.2 클래스와 프로퍼티`

자바에서는 필드와 접근자를 한데 묶어 `프로퍼티(property)`라고 부릅니다. 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신합니다. `val로 선언한 프로퍼티는 읽기 전용이며, var로 선언한 프로퍼티는 변경 가능합니다.`

```kotlin
class Person (
   val name: String,       // 읽기 전용 (비공개 필드 + public getter)    
   var isMarried: Boolean  // 쓸 수 있는 프로퍼티 (비공개 필드 + public getter, setter)
)

fun main() {
    val person = Person("Gyunny", true) // 객체 생성할 때 new를 사용하지 않음
    println(person.name) // getter 처럼 사용 가능
}
```

<br> <br>

## `2.3 선택 표현과 처리: enum과 when`

when은 자바의 switch를 대치하되 훨씬 더 강력하며, 앞으로 더 자주 사용할 프로그래밍 요소라고 생각할 수 있습니다. 

<br>

### enum 클래스 정의

```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```

위와 같이 단순하게 작성할 수도 있지만, enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있습니다. 

<br>

```kotlin
enum class Color(val r: Int, val g: Int, val b: Int) {
    RED(255, 0, 0), ORANGE(255, 165, 0), YELLOW(255, 255, 0);  // 코틀린에서 유일하게 세미콜론이 필요한 부분
    
    fun rgb() = (r * 256 + g) * 256 + b
}
```

<br> <br>

### `when으로 enum 클래스 다루기`

```kotlin
fun getMnemonic(color: Color) {
    when (color) {
        Color.RED -> "A"
        Color.ORANGE -> "B"
        Color.YELLO -> "C"
    }
}
```

자바