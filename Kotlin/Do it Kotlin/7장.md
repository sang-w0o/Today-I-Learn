## `추상 클래스`

추상 클래스는 `abstract` 라는 키워드와 함께 선언하며 추상 클래스로부터 일반적인 객체를 생성하는 방법으로 인스턴스화될 수 없습니다. 

```kotlin
abstract class Vehicle(val name: String, val color: String, val weight: Double) {
    
    // 추상 프로퍼티(반드시 하위 클래스에서 재정의해 초기화해야 함)
    abstract var maxSpeed: Double
    
    var year = "2018"
    
    // 추상 메소드(반드시 하위 클래스에서 구현해야 함)
    abstract fun start()
    abstract fun stop()
    
    fun displaySpecs() {
        println("Name: $name, Color: $color, Weight: $weight, Year: $year, Max Speed: $maxSpeed")
    }
}
```

자바와 비슷하게 `abstract` 키워드를 사용해서 `추상 클래스`를 구성합니다.  

<br>

```kotlin
class Car(name: String,
          color: String,
          weight: Double,
          override var maxSpeed: Double): Vehicle(name, color, weight) { // maxSpeed는 오버라이딩 함 

    override fun start() {
        TODO("Not yet implemented")
    }

    override fun stop() {
        TODO("Not yet implemented")
    }

}
```

하위 클래스에서 `abstract` 키워드가 있는 변수, 함수를 오버라이딩 한 것을 볼 수 있습니다.

<br> <br>

## `인터페이스`

인터페이스에는 `abstract`로 정의된 추상 메소드나 일반 메소드가 포함됩니다. 다른 객체지향 언어와는 다르게 메소드에 구현 내용이 포함될 수 있습니다.

```kotlin
interface Pet {
    var category: String   // abstract 키워드가 없어도 기본은 추상 프로퍼티
    fun feeding()          // 추상메소드
    fun petting() {        // 일반 메소드
        println("Keep patting")  
    }
}

class Cat(override var category: String) : Pet {
    override fun feeding() {
        println("Feed the Cat")
    }
}
```

인터페이스에서는 추상 클래스와는 다르게 `abstract`를 붙여 주지 않아도 기본적으로 추상 프로퍼티와 추상 메소드가 지정됩니다. 그리고 메소드에는 기본 구현부가 있으면 일반 메소드로서 기본 구현을 가집니다.

<br> <br>

## `데이터 클래스와 기타 클래스`

보통 자바에서는 데이터 전달을 위한 객체(`DTO(Data Transfer Object)`)를 POJO 라고 부르기도 합니다. 내부 로직을 가지지 않고 `getter`, `setter`, `toString`, `equals` 등과 같은 데이터를 표현하거나 비교하는 메소드를 가져야 합니다. 
코틀린에서는 DTO를 위해 `데이터 클래스`를 정의할 때 `getter`, `setter`, `toString()`, `equals()` 같은 메소드를 직접 만들 필요 없이 내부적으로 자동 생성됩니다. 

```kotlin
data class class Customer(var name: String, var email: String) {
    var job: String = "Doctor"
    
    constructor(name: String, email: String, job: String): this(name, email) {
        this.job = job
    }
}
```

그리고 데이터 클래스는 아래와 같은 조건을 만족해야 합니다.

- 주 생성자는 최소한 하나의 매개변수를 가져야 한다.
- 주 생성자의 모든 매개변수는 val, var로 지정된 프로퍼티여야 한다.
- 데이터 클래스는 abstract, open, sealed, inner 키워드를 사용할 수 없다.

<br>

<img width="1168" alt="스크린샷 2021-08-18 오전 12 34 44" src="https://user-images.githubusercontent.com/45676906/129756266-a696d001-b782-45b7-8186-0832c9c1f188.png">

<br> <br>

## `객체 디스트럭처링 하기`

```kotlin
fun main(args: Array<String>) {
    runApplication<AusgApplication>(*args)

    val cus1 = Customer("Gyunny", "Gyunny@naver.com")
    val (name, email) = cus1
    println("$name | $email")
}


data class Customer(var name: String, var email: String) {
}
```

<br> <br>

## `inner class`

```java
class A {
    class B { // java 의 inner class
        
    }
}
```

```kotlin
class A {
    inner class B { // java와 달리 inner 키워드 필요
        
    }
}
```

위와 같이 `java`, `kotlin`이 차이가 있습니다.

<br> 

## `static class`

```java
class A {
    static class B { // 정적 클래스를 위해 static 키워드 사용
        
    }
}
```

```kotlin
class A {
    class B { // Kotlin에서는 아무 키워드가 없는 클래스는 중첩 클래스이며 정적 클래스처럼 사용
        // 외부 클래스 A의 프로퍼티, 메소드에 접근할 수 없음
    }
}
```

코틀린에서 중첩 클래스는 기본적으로 `정적(static) 클래스` 처럼 다루어집니다.

<br> <br>

## `enum class`

```kotlin
enum class Direction {
    NORTH, SOUTH, WEST, EAST
}
```

```kotlin
enum class DayOfWeek(val num: Int) {
    MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4)
}
```

<br> <br>

## `연산자`

```kotlin
if (i in 1..10) { 
    println(i)  // 1 <= i && i <= 10 동일
}
```

```kotlin
for (i in 1..4) print(i) // "1234" 출력
```

