# `1장: 오브젝트와 의존관계`

- `관심사의 분리`: 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것(P61)

<br>

## `템플릿 메소드 패턴(template method pattern)`

![스크린샷 2022-03-19 오후 9 27 51](https://user-images.githubusercontent.com/45676906/159121132-8f334a76-79c1-43b1-a3ad-13f15a9f9e62.png)

> 슈퍼 클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법

<br>
 
추상 클래스를 사용하고 `abstract 메소드`를 하위 클래스에서 오버라이딩하는 패턴이 `템플릿 메소드 패턴`이라고 이해가 되는데.. 잘 이해한 것일까..?

<br>

## `팩토리 메소드 패턴`

![스크린샷 2022-03-19 오후 9 38 00](https://user-images.githubusercontent.com/45676906/159121416-a564795e-5ff9-4d9c-9964-b73802efceef.png)

> 서브 클래스의 getConnection() 메소드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드다. 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법 <br>
> 이렇게 서브 클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 `팩토리 메소드 패턴` 이라고 부른다.

<br>

위의 구조는 `상속(extends)`을 사용해서 리팩터링 한 결과인데, `상속`을 사용했다는 것이 깔끔하지 못하다. 그래서 `상속`이 아닌 클래스를 분리하는 방법으로 진행해보자.

<br>

![스크린샷 2022-03-20 오전 12 51 10](https://user-images.githubusercontent.com/45676906/159128249-6dae69b3-d0d9-4c3f-856c-20ecd59294ee.png)

위와 같이 `SimpleConnectionMaker`를 새로운 클래스로 만들어 `Connection`을 연결하는 역할을 하는 것을 따로 분리했다. 

```java
public class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;
    
    public UserDao() {
        simpleConnectionMaker = new SimpleConnectionMaker();
    }
    
    // add
    // get
}
```

그런데 `SimpleConnectionMaker`로 분리를 했어도 결국 `UserDao` 클래스 내부에서 `SimpleConnectionMaker` 의존성을 생성하기 때문에 강한 결합이 생길 수 밖에 없다. 

그래서 도입하는 것이 `인터페이스`를 사용하는 것이다.

<br>

![스크린샷 2022-03-20 오전 1 04 33](https://user-images.githubusercontent.com/45676906/159128725-ba574883-77d8-47f6-9bf6-e2543b75e17d.png)

`UserDao` 입장에서는 인터페이스만 참조하면 되고, 내부 구현체에 대해서 알 필요가 없기에 이렇게 인터페이스를 사용하면 유연한 구조를 가질 수 있다.

```java
public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao {
        connectionMaker = new DConnectionMaker();
    }
}
```

그런데 코드를 보니 아직도 `UserDao` 클래스에서 인터페이스 구현체를 알고 있다. 런타임에 `UserDao`와 구현체와의 관계가 생기는 것이 아니라 코드 상에서부터 어떤 구현체와 연결될 것인지를 알고 있기 때문에 `UserDao`와 `DConnectionMaker` 사이에 강합 결합이 생기게 된다.

그래서 `UserDao`와의 연관관계를 `UserDao`에서 만드는 것이 아니라 `외부에서 주입해주는 방식`을 사용할 수 있다. 이렇게 외부에서 주입해주게 되면 `런타임`에 `UserDao`와 `구현체` 사이의 연관관계가 생기게 된다.

<br>

```java
public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }
}
```

위와 같이 생성자를 통해서 `ConnectionMaker`를 외부에서 주입 받게 되면 `UserDao`는 `ConnectionMaker` 인터페이스만 참조할 수 있게 되어 결합도가 낮춰지게 된다. 즉, 인터페이스의 구현체를 바꾸더라도 `UserDao` 영향이 없게 된다.

<br>

## `개방 폐쇄 원칙`

`개방 폐쇄 원칙(OPC: Open-Closed-Priciple)은 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.` 라고 할 수 있다. 

<br>

## `높은 응집도`

- 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻

<br>

## `낮은 결합도`

- 결합도가 낮으면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다.
- 결합도란 `하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도`라고 설명할 수 있다.

<br>

## `전략 패턴`

![스크린샷 2022-03-20 오후 12 35 36](https://user-images.githubusercontent.com/45676906/159146936-63dbfbad-8e4e-40e3-ba16-da237f1a42ab.png)

`UserDao`는 `ConnectionMaker` 인터페이스를 참조한다. 즉, 인터페이스 구현체가 바뀌어도 `UserDao`에는 영향을 받지 않는다. 그리고 `UserDao`와 `ConnectionMaker` 인터페이스 구현체 사이에 의존 관계는 런타임에 생성된다. 이러한 패턴을 `전략 패턴`이라고 한다.

`전략 패턴은 디자인 패턴의 꽃이라고 불릴 만큼 다양하게 자주 사용되는 패턴`이다.

<br>

## `제어의 역전(IoC)`

![스크린샷 2022-03-20 오후 12 50 01](https://user-images.githubusercontent.com/45676906/159147313-5e976d3a-7b41-47ee-9898-1026ca1beded.png)

`UserDao`와 `ConnectionMaker`는 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있고, `DaoFactory`는 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있다.

여전히 우리의 핵심 기술이 담긴 UserDao는 변경이 필요 없으므로 변경에 닫혀있다고 할 수 있다.

<br>

## `제어권의 이전을 통한 제어관계 역전`

제어의 역전이란 스스로 어떤 객체와 의존관계를 맺을 것인지를 정하는 것이 아니라 사용하는 쪽에서 의존관계를 맺을 객체를 생성해서 넘겨주는 것을 말한다. 즉, `UserDao` 입장에서는 어떤 객체와 의존 관계 맺을지를 스스로 정하는 것이 아니라 외부에서 주입을 해주는 형태이다.

자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해 `DaoFactory`를 도입했던 과정이 바로 `IoC`를 적용하는 작업이었다.

제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.

<br>

## `스프링의 IoC`

스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 `빈(Bean)`이라고 부른다. 그리고 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 `빈 팩토리(Bean Factory)` 라고 한다. 보통 빈 팩토리보다는 이를 좀 더 확장한 `애플리케이션 컨텍스트(application context)`라고 한다.

<br>

## `애플리케이션 컨텍스트의 동작방식`

스프링에서는 이 애플리케이션 컨텍스트를 `IoC 컨테이너`라 하기도 하고, 간단히 스프링 컨테이너라고 부르기도 한다. 또는 `빈 팩토리(Bean Factory)` 라고 부를 수도 있다.

![스크린샷 2022-03-20 오후 1 24 23](https://user-images.githubusercontent.com/45676906/159148080-da85050b-d448-48f7-a6ad-9be7b90a5430.png)

위의 그림은 애플리케이션 컨텍스트가 동작하는 그림이다. (`@Configuration`이 붙은 `DaoFactory`는 애플리케이션 컨텍스트가 활용하는 `IoC 설정 정보`이다.)

1. 애플리케이션 컨텍스트는 DaoFactory 클래스를 설정정보로 등록해두고 `@Bean`이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다.
2. 클라이언트가 애플리케이션 컨텍스트의 `getBean()` 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾고, 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다.

<br>

## `애플리케이션 컨텍스트를 사용했을 때의 장점`

- ### `클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.`
  - 애플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 아무리 많아져도 이를 알아야 하거나 직접 사용할 필요가 없다.(애플리케이션 컨텍스트 안에서 알아서 관리해주기 때문에 클라이언트인 우리는 편하게 사용할 수 있다.)

- ### `애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.`
  - 애플리케이션 컨텍스트의 역할을 단지 오브젝트 생성과 다른 오브젝트와의 관계설정만이 전부가 아니다. `오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 이에 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.`

- ### `애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.`
  - 애플리케이션 컨텍스트의 `getBean()` 메소드는 빈의 이름을 이용해 빈을 찾아준다. 타입만으로 빈을 검색하거나 특별한 애노테이션 설정이 되어 있는 빈을 찾을 수도 있다.

<br>

## `스프링 IoC의 용어 정리`

### `빈(Bean)`

빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다.

<br>

### `빈 팩토리(Bean Factory)`

스프링의 IoC를 당당하는 핵심 컨테이너를 가리킨다. 빈을 등록하고, 생성하고 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당한다.

<br>

### `애플리케이션 컨텍스트`

빈 팩토리를 확장한 IoC 컨테이너다. 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일하다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다. 빈  팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고, 애플리케이션 컨텍스트라고 할 떄는 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것이라고 보면 된다.

<br>

## `설정정보/설정 메타정보`

스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다.

<br>

## `싱글톤 레지스트리로서의 애플리케이션 컨텍스트`

애플리케이션 컨텍스트는 우리가 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너이다. 그러면서 동시에 `애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리`이기도 하다.

`스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.`

<br>

## `서버 애플리케이션과 싱글톤`

`왜 스프링은 싱글톤으로 빈을 만드는 것일까?` 이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다. 스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다.

그런데 매번 클라이언트에서 요청이 올때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 생각해보자. 아무리 GC 성능이 좋아도 부하가 있을 수가 있다.

<br>

## `싱글톤 패턴의 일반적인 구현 방법`

자바에서 싱글톤을 구현하는 방법은 아래와 같다.

- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
- 스태틱 팩토리 메소드인 `getInstance()`를 만들고 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다. 
- 한번 오브젝트가 만들어지고 난 후에는 이미 만들어져 스태틱 필드에 오브젝트를 넘겨준다.

<br>

## `싱글톤 패턴의 한계`

- ### `private 생성자를 갖고 있기 때문에 상속할 수 없다.`
  - 싱글톤 패턴은 생성자를 private로 제한한다. private 생성자를 가진 클래스를 다른 생성자가 없다면 상속이 불가능하다는 점이다. 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다.

- ### `싱글톤은 테스트하기가 힘들다.`
  - 싱글톤은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다. 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 Mock 오브젝트 등으로 대체하기가 힘들다.

- ### `서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.`
  - 여러 개의 JVM에 분산되어 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.

- ### `싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.`
  - 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.

<br>

## `싱글톤 레지스트리`

자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, `스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 싱글톤 레지스트리`이다.

스프링 `IoC 컨테이너`를 사용하면 `평범한 자바 클래스라도 IoC 방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다. 오브젝트 생성에 관한 모든 권한 IoC 기능을 제공하는 애플리케이션 컨텍스트에 있기 때문이다.`

가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴등을 적용하는 데 아무런 제약이 없다.

<br>

## `스프링 빈의 스코프`

스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위에 대해 알아보자. 스프링에서는 이것은 `빈의 스코프(Bean Scope)` 라고 한다. 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프트는 컨테이너 내의 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다.

경우에 따라 싱글톤 외의 스코프를 가질 수 있다.

- 프로토타입(prototype): 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만드는 스코프
- 요청(request): 새로운 HTTP 요청이 생길때마다 생성되는 요청 스코프
- 세선(session): 웹의 세션과 스코프가 유사한 세션 스코프

<br>

## `의존관계 주입(DI)`

`DaoFactory`처럼 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의 IoC 컨테이너다. 이를 좀 더 명확하게 이해하기 위해서는 `의존 관계 주입` 이라는 용어를 이해해야 한다.

![스크린샷 2022-03-20 오후 2 35 23](https://user-images.githubusercontent.com/45676906/159149690-22c2955c-2867-4fc8-98ae-c536dde9cf43.png)

그림을 보면 `A가 B를 참조하고 있는데, 이를 A가 B에 의존하고 있다` 라고 표현한다. 의존한다는 건 의존대상인 B가 변하면 그것이 A에 영향을 미친다는 뜻이다.

![스크린샷 2022-03-20 오후 12 35 36](https://user-images.githubusercontent.com/45676906/159146936-63dbfbad-8e4e-40e3-ba16-da237f1a42ab.png)

그런데 이렇게 A가 B를 직접 참조하도록 하는 것이 아니라 A가 인터페이스를 참조하도록 하면 A와 B 사이의 결합도가 낮아진다. 인터페이스의 구현체를 바꿔도 A 클래스에는 변화가 없다.

그리고 런타임에 `A` 클래스와 구현체 사이의 의존관계가 생기게 된다. 즉, `스프링 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제3의 존재라고 볼 수 있다.` 동시에 IoC 방식으로 오브젝트의 생성과 초기화, 제공 등의 작업을 수행하는 컨테이너다. 

```java
public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }
}
```

`ConnectionMaker` 의존성을 `UserDao` 내부에서 생성하는 것이 아니라 사용하는 클라이언트 쪽에서 생성하여 생성자 파라미터를 통해서 주입해주는 것을 `의존관계 주입`이라고 한다.

코드에는 런타임 클래스에 대한 의존관계가 나타나지 않고, 인터페이스를 통해 결합도가 낮은 코드를 만드므로, 다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에는 자유롭다는 게 지금까지 설명한 장점이다.

<br>

## `Reference`

- [토비의 스프링]()