# `2장: 테스트`

> 스프링 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면 나는 주저하지 않고 `객체지향`과 `테스트`라고 대답할 것이다. P.145

> 스프링은 IoC/DI를 이용해 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와주는 기술이다. P.145

> 애플리케이션은 계속 변하고 복잡해져 간다. 그 변화에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면, 두 번째 전략은 만들어진 코드를 확실할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술이다. P.145

> 테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확실할 수 있게 해주는 작업이다. P.146

<br>

## `웹을 통한 DAO 테스트 방법의 문제점`

보통 웹 프로그램에서 사용하는 DAO를 테스트하는 방법은 다음과 같다. DAO를 만든 뒤 바로 테스트하지 않고, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다. 그리고 애플리케이션을 실행한 후에 웹으로 부터 값을 입력하여 작성한 코드가 정상적으로 작동하는지 확인한다.

하지만 위와 같은 테스트 방법은 단점이 너무나 많다. `DAO 뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다.` 테스트 하는 중에 에러가 발생하면 어디서 에러가 발생했는지 찾는데도 시간이 걸리는 수고가 필요하다. 

테스트 해보고 싶은 것은 DAO 인데, 다른 계층의 코드와 컴포넌트가 참여하기 때문에 테스트 하기가 번거롭고 오류가 있을 때 빠르게 대응하기가 쉽지 않을 수 있다.

<br>

## `작은 단위의 테스트`

테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 한꺼번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다.

따라서 `테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.` 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 `단위 테스트(Unit Test)` 라고 한다.

일반적으로 단위는 작을수록 좋다. 단위를 넘어서는 다른 코드들은 신경쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.

> 어떤 개발자는 테스트 중에 DB가 사용되면 단위 테스트가 아니라고도 한다. 하지만 사용할 DB의 상태를 테스트가 관장하고 있다면 이는 단위 테스트라고 해도 된다. 다만, DB의 상태가 매번 달라지고, 테스트를 위해 DB를 특정 상태로 만들어줄 수 없다면 그 떄는 DAOTest가 단위 테스트로서 가치가 없어진다. 즉, 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 하는 것이다. P.149

<br>

떄로는 `통합 테스트`를 진행하는 것도 필요하지만, 단위 테스트를 하는 이유는 개발작라 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다. `단위 테스트는 주로 개발자가 만든 코드를 스스로 확인하기 위해 사용하는데, 그래서 이를 개발자 테스트 또는 프로그래머 테스트라고도 한다.`

<br>

## `테스트 결과의 일관성`

테스트가 외부 상태에 따라 성공하기도 하고, 실패하기도 하면 안된다. 반본적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. `코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.`

> 단위 테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다. <br>
> 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안 된다. DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순설을 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

<br>

> 주의해야 할 점은 여러 개의 테스트가 어떤 순서로 실행될지는 알 수 없다는 것이다. JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야 한다. P.170

<br>

> 스프링의 창시자인 로드 존슨은 `항상 네거티브 테스트를 먼저 만들라`는 조언을 했다. P.175

<br>

## `JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식`

1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.(JUnit5는 public 없어도 됨)
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
8. 모든 테스트의 결과를 종합해서 알려준다.

<br>

한 가지 꼭 기억해야 할 사항은 `각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다는 점이다`. 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다. 즉, `테스트 클래스가 @Test 메소드를 두 개 가지고 있다면, 테스트가 실행되는 중에 JUnit은 이 클래스의 오브젝트를 두 번 만들게 된다.`

<br>

## `왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는 것일까?`

테스트 클래스마다 하나의 오브젝트만 만들어놓고 사용하는 편이 성능도 낫고 더 효율적이지 않을까 생각할 수 있다. `JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 했다.`

```java
public class UserDaoTest {
    private UserDao dao;
    private User user1;
    private User user2;
    private User user3;

    @Before
    void setUp() {
        user1 = new User("Gyunny1", "Spring1"),
        user2 = new User("Gyunny2", "Spring2"),
        user3 = new User("Gyunny3", "Spring3")
    }
}
```

오브젝트 생성은 `@Before`에서 하고 있다. 어차피 매번 새로운 테스트 오브젝트가 만들어지니까 인스턴스 변수에서 바로 초기화해도 상관없다.

<br>

## `스프링 테스트 적용`

`@Before` 메소드가 테스트 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트도 세 번 만들어진다. 애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다. 또한 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 제법 많은 시간을 필요로 한다.

또 한 가지 문제는 애플리케이션 컨텍스트가 초기화될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다. 이런 경우에는 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있다.

그래서 `애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다.` 빈은 싱글톤으로 만들었기 때문에 상태를 가지지 않는다. 따라서 애플리케이션 컨텍스트는 한 번만 만들고 여러 테스트가 공유해서 사용해도 된다.