## `DataBase`

### `1) ACID가 무엇인지 설명해주세요.`

```
Atomic(원자성)

- 중간 단계까지 실행되고 실패하는 일은 없다.
- 구매자의 돈이 빠졌지만 판매자의 돈이 들어오지 않는 경우


Consistency(일관성)

- 트랜잭션 작업 처리 결과는 항상 일관성 있어야 한다. 
- 마이너스 통장을 허락하지 않는다면 조건에 위배되면 트랜잭션 종료


Isolation(독립성)

- 둘 이상의 트랜잭션이 동시 실행되고 있을 때 다른 트랜잭션이 끼어들 수 없다.
- 구매자의 돈이 빠졌지만 판매자의 돈이 아직 안들어왔는데 다른 트랜잭션이 끼어들 수 없다.


Durability(지속성)

- 트랜잭션이 성공적으로 완료되었으면 결과는 영구히 반영되어야 한다.

```

<br>

### `2) 트랜잭션 격리레벨에 대해서 설명해주세요.`

<img width="1047" alt="스크린샷 2021-11-25 오후 10 25 08" src="https://user-images.githubusercontent.com/45676906/143449504-f1f2b6cd-5c2a-4cf8-90fe-39f6d0f700c0.png">

- READ UNCOMMITED 
  - 가장 격리가 낮은 단계입니다. 다른 트랜잭션에서 커밋하지 않은 데이터도 조회할 수 있다는 문제점이 존재합니다. 그래서 사용하지 않습니다.

- READ COMMITTED 
  - Oracle DBMS에서 기본적으로 사용하고 있는 격리 수준이며, 다른 트랜잭션에서 데이터를 변경했더라도 COMMIT 한 데이터만 보입니다. 하지만 이 격리 레벨에서도 NON-REPEATABLE READ의 문제점이 존재합니다. NON-REPEATABLE READ란 같은 쿼리를 같은 트랜잭션에서 2번 실행했는데 결과가 다른 부정합을 말합니다.

- REPEATABLE READ 
  - MySQL InnoDB에서 기본적으로 사용되고 있는 격리 수준입니다. `바이너리 로그를 가진 MySQL 장비`에서는 최소 이 격리 수준을 사용해야 합니다.  
  - 자신의 트랜잭션보다 낮은 트랜잭션에서 변경된 것만 보게 됩니다. 
  - InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경합니다. 이러한 방식을 MVCC 라고 합니다. 사실 READ COMMITTED 도 MVCC 를 이용해 COMMIT 되기 전의 데이트를 보여준다. 두 개의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하는지에 있다. 
  - 하지만 이 격리 수준에서도 PHANTOM READ 부정합 문제가 발생합니다. PHANTOM READ 는 보이지 않았던 결과가 보이는 것이다.
  - UPDATE 쿼리는 이전 트랜잭션 꺼만 보지만, 다른 트랜잭션에서 INSERT, DELETE 한 경우에 PHANTOM READ 가 발생한다.

- SERIALIZABLE
  - 트랜잭션이 완료될 때까지 다른 트랜잭션이 해당되는 영역에 대한 수정 및 입력을 할 수 없습니다.
  - 모든 작업을 하나의 트랜잭션에 처리하는 것과 같은 높은 고립수준을 제공하는데, 이로인해 동시성 처리 효율은 매우 떨어진다.
  
<br>

## `트랜잭션이 무엇인지도 설명해주세요`

- 트랜잭션이란 쿼리를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 `Rollback`을 수행하고, 오류없이 실행을 마치면 `commit`을 하는 실행 단위를 의미합니다.

<br>

## `트랜잭션을 사용하는 이유가 무엇이라고 생각하시나요?`

- 트래픽이 많이 몰려서 동시에 여러 클라이언트에 DB 서버로 접근한다면 데이터베이스의 부정합이 많이 발생할 수 있습니다. 
- 부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리하도록 하면 되는데, 이는 효율이 너무 떨어집니다. 렬로 처리할 수 밖에 없는 현실적인 상황으로 인해 부정합을 방지하고자 트랜잭션을 사용합니다. 

<br>

### `3) 데이터베이스 정규화에 대해서 설명해주세요.`

> 1차 정규화 : 하나의 컬럼에는 하나의 값만 들어가야 한다. ,를 구분해서 값을 넣지 않음

> 2차 정규화 : 식별자(기본키)가 여러 개 일 때 식별자(기본 키) 일부에만 종속되는 어트리뷰트는 제거해야 한다.

> 3차 정규화 : 식별자(기본키)가 아닌 속성에 다른 속성에 종속되는 어트리뷰트가 존재하면 안된다.

<br>

### `4) 인덱스란 무엇인지 설명해주세요.`

> 인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할 수 있다. DBMS에서 검색 속도를 향상시키기 위해 인덱스를 사용합니다. 하지만 인덱스를 사용함으로써 INSERT, UPDATE 성능은 희생해야 합니다. 카디널리티 값은 높아야 인덱스 사용에 유용함 ex) 주민번호 But 성별 같은 정보는카디널리티 값이 낮음

<br>

### `잘 적용된 index란?`

- 카디널리티(Cardinality)가 가장 높은 것을 잡아야 한다는 점입니다.

- 카디널리티(Cardinality): 해당 컬럼의 중복된 수치를 나타냅니다. 
  - 예를 들어 성별, 학년 등은 카디널리티가 낮다고 얘기합니다. - 반대로 주민등록번호, 계좌번호 등은 카디널리티가 높다고 얘기합니다.

- 인덱스로 최대한 효율을 뽑아내려면, 해당 인덱스로 많은 부분을 걸러내야 하기 때문입니다. 카디널리티가 높은 칼럼부터 낮은 순서대로 인덱스 생성

<br>

### `B-Tree 인덱스`

B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘 입니다. (Binary(X), Balanced Tree)

<br>

### `인덱스 키 추가`

B-Tree에 저장될 위치가 정해지면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. 만약 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리되어야 하는데, 이는 상위 브랜치 논드까지 처리의 범위가 넓어진다. 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려져 있다. 

<br>

### `인덱스 키 삭제`

B-Tree 키 값이 삭제되는 경우는 상당히 간단한다. 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다. 

<br>

### `인덱스 키 변경`

인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다. B-Tree의 키 값 변경 작업은 먼저 키 값을  삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

<br>

### `인덱스 키 검색`

`INSERT, UPDATE, DELETE` 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다. 

인덱스 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 `트리 탐색` 이라고 합니다. 

<br>

## `해시 인덱스`

해시 인덱스는 B-Tree 만큼 범용적이지 않지만 고유의 특성과 용도를 지닌 인덱스 가운데 하나다. `해시 인덱스는 동등 비교 검색에는 최적화되어 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다. 일반적인 DBMS에서 해시 인덱스는 메모리 기반의 테이블에 주로 구현되어 있으며 디스크 기반의 대용량 테이블용으로는 거의 사용되지 않는다는 특징이 있다.` 

<br>

### `5) INNER JOIN과 OUTER JOIN의 차이를 말해주세요.`

```
INNER 조인은 서로 교집합이 해당하는 부분만을 가져옵니다. 

반면에 OUTER JOIN에는 LEFT OUTER JOIN, RIGHER OUTER JOIN이 있는데 LEFT OUTER JOIN이면 교집합 + 왼쪽에 해당하는 것들을 가져옵니다. 
즉, 겹치는 것이 없더라도 NULL을 채워서 가져옵니다.
```

<br>

### `union 과 JOIN 의 차이는 무엇인가요?`



<br> 

### `6) 언두 영역이란?`

- 언두 영역은 UPDATE 문장이나 DELETE 문장으로 데이터를 변경했을 때 변경되기 전의 데이터(이전 데이터)를 보관하는 곳입니다.

<br>

### `7) MVCC 란?`

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있습니다. InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경합니다. 이러한 방식을 MVCC 라고 합니다. 

<br>

### `8) 데이터베이스 키`

- 슈퍼키 : 테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합. 슈퍼키는 `유일성`만 만족하면 슈퍼키가 될 수 있다.
- 후보키 : 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합. `유일성`, `최소성`을 동시에 만족해야 한다. 

<br>

## `복제(Replication)`

![1212](https://user-images.githubusercontent.com/45676906/119230561-b64d4c00-bb57-11eb-80f0-c766d5732a39.png)

- `복제`는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술

- 일반적으로 MySQL 복제에는 INSERT, UPDATE와 같은 쿼리를 이용해 데이터를 변경할 수 있는 MySQL 서버와 SELECT 쿼리로 데이터를 읽기만 할 수 있는 MySQL 서버로 나뉜다.

- 전자를 `마스터(master)` 후자를 `슬레이브(Slave)`라고 함

<br>

### `마스터(Master)`

- MySQL의 바이너리 로그가 활성화되면 어떤 MySQL 서버든 마스터가 될 수 있다.

<br>

### `슬레이브(Slave)`

- `마스터 서버가 바이너리 로그`를 가지고 있으면 `슬레이브 서버는 릴레이 로그`를 가지고 있다.

- 슬레이브 서버의 I/O 스레드는 마스터 서버에 접속해 변경 내역을 요청하고, 받아 온 변경 내역을 릴레리 로그에 기록한다. 슬레이브 서버의 SQL 스레드가 릴레이 로그에 기록된 변경 내역을 재실행 함으로써 슬레이브 데이터를 마스커와 동일한 상태로 유지함

<br>

### `슬레이브는 하나의 마스터만 설정 가능`

- MySQL 복제에는 하나의 슬레이브는 하나의 마스터만 가질 수 있다.

- 하나의 마스터에 N개의 슬레이브가 일반적인 형태

<br>

### `마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정`

- 슬레이브는 `읽기 전용`으로 하기

<br>

### `슬레이브 서버용 장비는 마스터와 동일한 사양이 적합`

- 오히려 마스터보다 슬레이브 사양이 더 좋아야 함 (자주 변경이 있는 마스터 서버라면 특히 더!)

<br>

### `복제가 불필요한 경우에는 바이너리 로그 중지`

- 바이너리 로그를 작성하기 위해 MySQL은 큰 자원을 소모함


<br>

### `바이너리 로그`

- 바이너리 로그 파일은 데이터베이스 변경(테이블 생성, 삭제 등) 및 테이블 변경(insert, update, delete ..) 사항들이 기록되는 바이너리 형태의 파일입니다.
- 바이너리 로그의 내용을 기반으로 하여 마스터 서버에서 슬레이브 서버로 데이터를 전송하고 복제할 수 있으며, 데이터를 복원하는데 사용하기도 합니다.

<br>

## `파티셔닝이란 무엇인가요?`

하나의 DBMS가 많은 테이블을 관리 하기 힘들어지고, 속도도 저하

=> 파티셔닝 등장

- 파티셔닝 : `큰 테이블이나 인덱스를 관리하기 쉬운 단위로 분리하는것`
- 장점 
  - 특정 DML과 쿼리의 성능을 향상시키며, Data Write 환경에서 효율적이다 
  - 많은 Insert가 있는 OLTP 시스템에서 특히 경합을 더 줄일 수 있다

<br>

## `Scale Out vs Scale Up 이 무엇인지 설명해주세요.`

### Scale Out

- 기존의 서버와 같은 사양 또는 비슷한 사양의 서버 대수를 증가시키는 방법으로 처리 능력을 향샹시키는 것을 말한다. 스케일 아웃 방식을 "수평 스케일"이라고 부르기도 하고, 확장이 스케일 업보다는 다소 유연하다.
- 1’의 처리 능력을 가진 서버에 동일한 서버 4대를 더 추가하여, 총 ‘5’의 처리 능력을 만드는 것이다. 서버가 여러 대가 되기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 ‘로드밸런싱’이 필수적으로 동반되어야 한다.
- 즉, 여러 대의 서버가 분산(나누어) 처리할 수 있도록 요청을 나누어주는 서비스

<br>

### Scale Up

- 성능이나 용량 증강을 목적으로 하나의 서버에 디스크를 추가하거나 CPU나 메모리를 업그레이드시키는 것을 말한다. 하나의 서버의 능력을 증강하기 때문에 수직 스케일링(vertical scaling)이라고도 한다.
- 즉, 기존의 하드웨어를 보다 높은 사양으로 업그레이드하는 것을 말한다.

<br>

### 공유 잠금이란?

```
공유 잠금이 설정되어 있는 동안 다른 트랜잭션이 데이터를 변경할 수 없다. 
레코드나 간격을 읽을 때 다른 트랜잭션이 변경하지 못하게 하는 용도의 잠금 즉, 읽기 전용 작업
```

<br>

### 베타적 잠금

```
다른 트랜잭션이 읽거나 수정할 수 없다. 즉, 해당 트랜잭션에서 그 레코드나 간격을 변경하기 위해 획득해야 하는 잠금 
```

정리하면 `베타적 잠금은 내가 쓰기를 하는 동안 남들이 쓰지 못하게 하는 것`이고, `공유 잠금은 내가 읽는 동안 남들이 내가 읽고 있는 데이터를 변경하거나 삭제하지 못하게 하는 장치`입니다.
 
<br>

