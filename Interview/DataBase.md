## `DataBase`

### `1) ACID가 무엇인지 설명해주세요.`

```
Atomic(원자성)

- 중간 단계까지 실행되고 실패하는 일은 없다.
- 구매자의 돈이 빠졌지만 판매자의 돈이 들어오지 않는 경우



Consistency(일관성)

- 트랜잭션 작업 처리 결과는 항상 일관성 있어야 한다. 
- 마이너스 통장을 허락하지 않는다면 조건에 위배되면 트랜잭션 종료



Isolation(독립성)

- 둘 이상의 트랜잭션이 동시 실행되고 있을 때 다른 트랜잭션이 끼어들 수 없다.
- 구매자의 돈이 빠졌지만 판매자의 돈이 아직 안들어왔는데 다른 트랜잭션이 끼어들 수 없다.


Durability(지속성)

- 트랜잭션이 성공적으로 완료되었으면 결과는 영구히 반영되어야 한다.

```

<br>

### `2) 트랜잭션 격리레벨에 대해서 설명해주세요.`

- READ UNCOMMITED 
  - 가장 격리가 낮은 단계입니다. 다른 트랜잭션에서 커밋하지 않은 데이터도 조회할 수 있다는 문제점이 존재합니다. 그래서 사용하지 않습니다.

- READ COMMITTED 
  - Oracle DBMS에서 기본적으로 사용하고 있는 격리 수준이며, 다른 트랜잭션에서 데이터를 변경했더라도 COMMIT 한 데이터만 보입니다. 하지만 이 격리 레벨에서도 NON-REPEATABLE READ의 문제점이 존재합니다. NON-REPEATABLE READ란 같은 쿼리를 같은 트랜잭션에서 2번 실행했는데 결과가 다른 부정합을 말합니다.

- REPEATABLE READ 
  - MySQL InnoDB에서 기본적으로 사용되고 있는 격리 수준입니다. `바이너리 로그를 가진 MySQL 장비`에서는 최소 이 격리 수준을 사용해야 합니다.  
  - 모든 SELECT 쿼리는 자신의 트랜잭션 보다 작은 트랜잭션에서 변경한 것만 보기 때문에 `READ COMMITTED` 에서 발생하는 `UNREPEATABEL READ`가 발생하지 않습니다.
  - InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경합니다. 이러한 방식을 MVCC 라고 합니다. 사실 READ COMMITTED 도 MVCC 를 이용해 COMMIT 되기 전의 데이트를 보여준다. 두 개의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하는지에 있다. 
  - 하지만 이 격리 수준에서도 PHANTOM READ 부정합 문제가 발생합니다. 즉 하나의 트랜잭션 내에서 동일한 쿼리 두 번을 실행했을 때 쿼리 결과가 다를 수 있다는 문제점이 있습니다.

- SERIALIZABLE
  - 트랜잭션이 완료될 때까지 다른 트랜잭션이 해당되는 영역에 대한 수정 및 입력을 할 수 없습니다.

<br>

## `트랜잭션이 무엇인지도 설명해주세요`

- 트랜잭션이란 쿼리를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 `Rollback`을 수행하고, 오류없이 실행을 마치면 `commit`을 하는 실행 단위를 의미합니다.

<br>

### `3) 데이터베이스 정규화에 대해서 설명해주세요.`

> 1차 정규화 : 하나의 컬럼에는 하나의 값만 들어가야 한다. ,를 구분해서 값을 넣지 않음

> 2차 정규화 : 식별자(기본키)가 여러 개 일 때 식별자(기본 키) 일부에만 종속되는 어트리뷰트는 제거해야 한다.

> 3차 정규화 : 식별자(기본키)가 아닌 속성에 다른 속성에 종속되는 어트리뷰트가 존재하면 안된다.

<br>

### `4) 인덱스란 무엇인지 설명해주세요.`

> 인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할 수 있다. DBMS에서 검색 속도를 향상시키기 위해 인덱스를 사용합니다. 하지만 인덱스를 사용함으로써 INSERT, UPDATE 성능은 희생해야 합니다. 카디널리티 값으 높아야 인덱스 사용에 유용함 ex) 주민번호 But 성별 같은 정보는카디널리티 값이 낮음

<br>

### `잘 적용된 index란?`

카디널리티(Cardinality)가 가장 높은 것을 잡아야 한다는 점입니다.

카디널리티(Cardinality): 해당 컬럼의 중복된 수치를 나타냅니다. - 예를 들어 성별, 학년 등은 카디널리티가 낮다고 얘기합니다. - 반대로 주민등록번호, 계좌번호 등은 카디널리티가 높다고 얘기합니다.

인덱스로 최대한 효율을 뽑아내려면, 해당 인덱스로 많은 부분을 걸러내야 하기 때문입니다. 카디널리티가 높은 칼럼부터 낮은 순서대로 인덱스 생성

<br>

### `B-Tree 인덱스`

B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘 입니다. (Binary(X), Balanced Tree)

<br>

### `인덱스 키 추가`

B-Tree에 저장될 위치가 정해지면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. 만약 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리되어야 하는데, 이는 상위 브랜치 논드까지 처리의 범위가 넓어진다. 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려져 있다. 

<br>

### `인덱스 키 삭제`

B-Tree 키 값이 삭제되는 경우는 상당히 간단한다. 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다. 

<br>

### `인덱스 키 변경`

인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다. B-Tree의 키 값 변경 작업은 먼저 키 값을  삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

<br>

### `인덱스 키 검색`

`INSERT, UPDATE, DELETE` 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다. 

인덱스 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 `트리 탐색` 이라고 합니다. 

<br>

## `해시 인덱스`

해시 인덱스는 B-Tree 만큼 범용적이지 않지만 고유의 특성과 용도를 지닌 인덱스 가운데 하나다. 해시 인덱스는 동등 비교 검색에는 최적화되어 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다. 일반적인 DBMS에서 해시 인덱스는 메모리 기반의 테이블에 주로 구현되어 있으며 디스크 기반의 대용량 테이블용으로는 거의 사용되지 않는다는 특징이 있다 

<br>

### `5) INNER JOIN과 OUTER JOIN의 차이를 말해주세요.`

```
INNER 조인은 서로 교집합이 해당하는 부분만을 가져옵니다. 

반면에 OUTER JOIN에는 LEFT OUTER JOIN, RIGHER OUTER JOIN이 있는데 LEFT OUTER JOIN이면 교집합 + 왼쪽에 해당하는 것들을 가져옵니다. 
즉, 겹치는 것이 없더라도 NULL을 채워서 가져옵니다.
```

<br>

### `union 과 JOIN 의 차이는 무엇인가요?`



<br> 

### `6) 언두 영역이란?`

- 언두 영역은 UPDATE 문장이나 DELETE 문장으로 데이터를 변경했을 때 변경되기 전의 데이터(이전 데이터)를 보관하는 곳입니다.

<br>

### `7) MVCC 란?`

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있습니다. InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경합니다. 이러한 방식을 MVCC 라고 합니다. 

<br>

### `8) 데이터베이스 키`

- 슈퍼키 : 테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합. 슈퍼키는 `유일성`만 만족하면 슈퍼키가 될 수 있다.
- 후보키 : 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합. `유일성`, `최소성`을 동시에 만족해야 한다. 

<br>

## `복제(Replication)`

![1212](https://user-images.githubusercontent.com/45676906/119230561-b64d4c00-bb57-11eb-80f0-c766d5732a39.png)

- `복제`는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술

- 일반적으로 MySQL 복제에는 INSERT, UPDATE와 같은 쿼리를 이용해 데이터를 변경할 수 있는 MySQL 서버와 SELECT 쿼리로 데이터를 읽기만 할 수 있는 MySQL 서버로 나뉜다.

- 전자를 `마스터(master)` 후자를 `슬레이브(Slave)`라고 함

<br>

### `마스터(Master)`

- MySQL의 바이너리 로그가 활성화되면 어떤 MySQL 서버든 마스터가 될 수 있다.

<br>

### `슬레이브(Slave)`

- `마스터 서버가 바이너리 로그`를 가지고 있으면 `슬레이브 서버는 릴레이 로그`를 가지고 있다.

- 슬레이브 서버의 I/O 스레드는 마스터 서버에 접속해 변경 내역을 요청하고, 받아 온 변경 내역을 릴레리 로그에 기록한다. 슬레이브 서버의 SQL 스레드가 릴레이 로그에 기록된 변경 내역을 재실행 함으로써 슬레이브 데이터를 마스커와 동일한 상태로 유지함

<br>

### `슬레이브는 하나의 마스터만 설정 가능`

- MySQL 복제에는 하나의 슬레이브는 하나의 마스터만 가질 수 있다.

- 하나의 마스터에 N개의 슬레이브가 일반적인 형태

<br>

### `마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정`

- 슬레이브는 `읽기 전용`으로 하기

<br>

### `슬레이브 서버용 장비는 마스터와 동일한 사양이 적합`

- 오히려 마스터보다 슬레이브 사양이 더 좋아야 함 (자주 변경이 있는 마스터 서버라면 특히 더!)

<br>

### `복제가 불필요한 경우에는 바이너리 로그 중지`

- 바이너리 로그를 작성하기 위해 MySQL은 큰 자원을 소모함


<br>

### `바이너리 로그`

- 바이너리 로그 파일은 데이타베이스 변경(테이블 생성,삭제등) 및 테이블 변경(insert,update,delete ..) 사항들이 기록되는 바이너리 형태의 파일이다.

<br>

