# `DataBase`

## `Transaction`

<details>
  <summary>ACID가 무엇인지 설명해주세요.</summary>
  <br>

Atomic(원자성)

- 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력
  - 중간 단계까지 실행되고 실패하는 일은 없다.
  - 구매자의 돈이 빠졌지만 판매자의 돈이 들어오지 않는 경우


Consistency(일관성)

- 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것
  - 트랜잭션 작업 처리 결과는 항상 일관성 있어야 한다.
  - 마이너스 통장을 허락하지 않는다면 조건에 위배되면 트랜잭션 종료


Isolation(독립성)

- 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것
  - 둘 이상의 트랜잭션이 동시 실행되고 있을 때 다른 트랜잭션이 끼어들 수 없다.
  - 구매자의 돈이 빠졌지만 판매자의 돈이 아직 안들어왔는데 다른 트랜잭션이 끼어들 수 없다.


Durability(지속성)

- 트랜잭션이 성공적으로 완료되어 commit 되었다면 결과는 데이터베이스에 영구히 반영되어야 한다.

</details>

<details>
  <summary>은행에서 돈을 뽑을 때 관점에서 ACID Isolation 관점에서 설명해주세요.</summary>
  <br>

내가 돈을 5만원 뽑았는데 내 통장에 돈이 5만원 빠지기 전에 다른 트랜잭션이 끼어들 수 없다.

</details>

<details>
  <summary>트랜잭션 격리레벨에 대해서 설명해주세요.</summary>
  <br>

<img width="1047" alt="스크린샷 2021-11-25 오후 10 25 08" src="https://user-images.githubusercontent.com/45676906/143449504-f1f2b6cd-5c2a-4cf8-90fe-39f6d0f700c0.png">

- READ UNCOMMITTED
  - 가장 격리가 낮은 단계입니다. 다른 트랜잭션에서 커밋하지 않은 데이터도 조회할 수 있다는 문제점이 존재합니다. 그래서 사용하지 않습니다.

- READ COMMITTED
  - `Oracle DBMS 에서 기본적으로 사용하고 있는 격리 수준`이며, 다른 트랜잭션에서 데이터를 변경했더라도 COMMIT 한 데이터만 보입니다. 하지만 이 격리 레벨에서도 NON-REPEATABLE READ의 문제점이 존재합니다. NON-REPEATABLE READ란 같은 쿼리를 같은 트랜잭션에서 2번 실행했는데 결과가 다른 부정합을 말합니다.
  - 즉, A 트랜잭션에서 같이 쿼리를 2번 실행합니다. A 트랜잭션에서 쿼리를 첫 번째로 실행한 후에, B 트랜잭션에서 해당 쿼리가 조회하는 row 의 값을 Update 했습니다. 그러면 A 트랜잭션에서 같은 쿼리를 두 번째 조회했을 때는 첫 번째 실행했을 때와 결과가 다를 것입니다. 이렇게 하나의 A 트랜잭션 안에서 같은 쿼리를 여러 번 실행했을 때 결과가 다른 현상을 `NON-REPEATABLE-READ` 라고 합니다. 

- REPEATABLE READ
  - `MySQL InnoDB 에서 기본적으로 사용되고 있는 격리 수준`입니다. `바이너리 로그를 가진 MySQL 장비`에서는 최소 이 격리 수준을 사용해야 합니다.
  - `자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된 것만 보게 됩니다.`
  - InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK 될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경합니다. 이러한 방식을 `MVCC` 라고 합니다. 사실 READ COMMITTED 도 MVCC 를 이용해 COMMIT 되기 전의 데이터를 보여준다. 두 개의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하는지에 있습니다.
  - 하지만 이 격리 수준에서도 `PHANTOM READ` 부정합 문제가 발생합니다. PHANTOM READ 는 보이지 않았던 결과가 보이는 것이다.
  - REPEATABLE READ 격리 수준은 트랜잭션이 시작할 때 보다 이전 트랜잭션에서 커밋된 데이터만 조회하기 때문에 중간 트랜잭션에서 데이터를 바꿨어도 Undo 영역에서 조회하기 때문에 문제가 발생하지 않는다! 다른 트랜잭션에서 `INSERT, DELETE 한 경우에 데이터가 변경된 것이 아니라 새로 추가된 것이기 때문에 REPEATABLE READ 에서도 PHANTOM READ 가 발생`한다.
  - `PANTHOM READ`를 방지하기 위해서는 `쓰기 잠금`을 걸어야 한다.

- SERIALIZABLE
  - 트랜잭션이 완료될 때까지 다른 트랜잭션이 해당되는 영역에 대한 수정 및 입력을 할 수 없습니다.
  - `모든 작업을 하나의 트랜잭션에 처리하는 것과 같은 높은 고립수준을 제공하는데`, 이로인해 동시성 처리 효율은 매우 떨어진다.
  
<br>

- [참고하기 좋은 글](https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation

</details>

<details>
  <summary>트랜잭션이 무엇인지 설명해주세요</summary>
  <br>

트랜잭션이란 쿼리를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 `Rollback`을 수행하고, 오류없이 실행을 마치면 `commit`을 하는 실행 단위를 의미합니다.

</details>

<details>
  <summary>트랜잭션을 사용하는 이유 또는 필요한 이유가 무엇이라고 생각하시나요?</summary>
  <br>

- 트래픽이 많이 몰려서 동시에 여러 클라이언트에 DB 서버로 접근한다면 데이터베이스의 부정합이 많이 발생할 수 있습니다. 
- 부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리하도록 하면 되는데, 이는 효율이 너무 떨어집니다. 트랜잭션을 사용하지 않으면 부정합을 방지하고자 일렬로 처리해야 합니다. 이는 성능상 너무 좋지 않기 때문에 부정합도 방지하고 성능의 이점도 가져갈 수 있도록 `트랜잭션`을 사용합니다.
- 그리고 하나의 논리적인 단위에서 에러가 발생했을 때 롤백 해야 하는 문제를 해결할 수 있고, 커밋이 되면 데이터가 영구적으로 저장되도록 할 수 있는 특징이 있습니다.

</details>

<br>

## `Index`

<details>
  <summary>인덱스란 무엇인지 설명해주세요.</summary>
  <br>

`인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인(목차)`이라고 할 수 있다. DBMS 에서 검색 속도를 향상시키기 위해 인덱스를 사용합니다. 하지만 인덱스를 사용함으로써 INSERT, UPDATE 성능은 희생해야 합니다. 

카디널리티 값은 높아야 인덱스 사용에 유용합니다. ex) 주민번호는 카디널리티 값이 높습니다.(사람마다 개인의 고유 값이기 때문에 중복되지 않음) 하지만 성별은 일반적으론 `남자/여자` 정도만 있기 때문에 중복이 많이 되는 값이기 때문에 카디널리티 값이 낮습니다.

</details>

<details>
  <summary>잘 적용된 index란 무엇인가요?</summary>
  <br>

- `카디널리티(Cardinality)가 가장 높은 것을 잡아야 한다는 점`입니다.

- 카디널리티(Cardinality): `해당 컬럼의 중복된 수치`를 나타냅니다.
  - 예를 들어 성별, 학년 등은 카디널리티가 낮다고 얘기합니다. 반대로 주민등록번호, 계좌번호 등은 카디널리티가 높다고 얘기합니다.(겹칠 수 없는 고유 값이기 때문에)

- 인덱스로 최대한 효율을 뽑아내려면, 해당 인덱스로 많은 부분을 걸러내야 하기 때문입니다. 인덱스를 생성할 대는 카디널리티가 높은 칼럼부터 낮은 순서대로 인덱스 생성해야 합니다.

</details>

<details>
  <summary>B-Tree 인덱스에 대해서 설명해주세요.</summary>
  <br>

- `Binary Search` 자료구조의 한계를 극복하기 위해 나온 자료구조 입니다. 즉, `B-Tree`는 한 노드에 많은 자식 노드를 가질 수 있기 때문에 아무리 대용량 데이터여도 `Depth`가 `4 ~ 5` 정도가 된다는 특징이 있습니다.
- `B-Tree`는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘 입니다. (Binary(X), Balanced Tree)
- `B-Tree`는 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 `정렬된 상태로 유지`하고 있습니다.

<img width="611" alt="스크린샷 2021-12-01 오후 12 24 56" src="https://user-images.githubusercontent.com/45676906/144166491-45f240c4-deef-4584-80a9-dd51dc4ecc09.png">

- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있습니다.

</details>

<details>
  <summary>index를 사용할 때 index를 사용하지 못하는 검색 조건은 어떤게 있나요?</summary>
  <br>
</details>

<details>
  <summary>인덱스 삽입, 삭제, 수정, 검색 중에서 각각 어떤 특징이 있나요?</summary>
  <br>

### `인덱스 키 추가`

`B-Tree`에 저장될 위치가 정해지면 레코드의 키 값과 대상 레코드의 주소 정보를 `B-Tree`의 리프 노드에 저장한다. 만약 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리되어야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 이러한 작업 탓에 `B-Tree`는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려져 있다.

<br>

### `인덱스 키 삭제`

B-Tree 키 값이 삭제되는 경우는 상당히 간단한다. 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.

<br>

### `인덱스 키 변경`

인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다. B-Tree의 키 값 변경 작업은 먼저 키 값을  삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

<br>

### `인덱스 키 검색`

`INSERT, UPDATE, DELETE` 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다.

인덱스 검색하는 작업은 `B-Tree`의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 `트리 탐색` 이라고 합니다.

</details>

<details>
  <summary>복합 인덱스</summary>
  <br>

A, B 컬럼을 인덱스로 설정할 때 복합인덱스라 한다. 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다. 즉, 두 번째 컬럼 정렬은 첫 번째 컬럼이 똑같은 레코드에서만 의미가 있다.

</details>

<details>
  <summary>해시 인덱스</summary>
  <br>

해시 인덱스는 B-Tree 만큼 범용적이지 않지만 고유의 특성과 용도를 지닌 인덱스 가운데 하나다. `해시 인덱스는 동등 비교 검색에는 최적화되어 있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없다. 일반적인 DBMS에서 해시 인덱스는 메모리 기반의 테이블에 주로 구현되어 있으며 디스크 기반의 대용량 테이블용으로는 거의 사용되지 않는다는 특징이 있다.`

</details>

<details>
  <summary>Primary Index vs Secondary Index 차이가 무엇인가요?</summary>
  <br>

클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 클러스터드 인덱스도 크게 다르지 않다. 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다. 여기서 `비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말한다.`

`클러스터드 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다.` 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현한다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다. 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야 한다.

`클러스터드 인덱스는 테이블 당 한 개만 생성할 수 있다. 프라이머리 키에 대해서만 적용되기 때문이다, 이에 반해 non 클러스터드 인덱스는 테이블 당 여러 개를 생성할 수 있다.`

</details>

<br>

## `Redis`

<details>
  <summary>Redis 특징에 간단하게 설명해주세요.</summary>
  <br>

`Redis`는 key-value store NOSQL DB입니다. `싱글스레드`로 동작하며 다양한 자료구조를 지원합니다. 데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 `영속성`도 보장됩니다.

</details>

<details>
  <summary>Redis vs Memcached 차이점에 대해서 설명해주세요.</summary>
  <br>

- `Redis`는 `싱글 스레드 기반`으로 동작하고, `Memcached`는 `멀티스레드`를 지원해서 멀티 프로세싱이 가능합니다.

- Redis는 다양한 자료구조를 지원하고, Memcached는 문자열 형태로만 저장합니다.

- Redis는 여러 용도로 사용할 수 있도록 다양한 기능을 지원합니다.

- Redis는 스냅샷, AOF 로그를 통해서 데이터 복구가 가능합니다.

</details>

<details>
  <summary>캐시를 사용할 때 주의해야할 점이 무엇일까요?</summary>
  <br>

아무래도 캐시는 빠른 저장소고 필연적으로 사이즈가 작기 때문에 유용할 것 같은 데이터만 남겨두고 필요 없는 데이터는 적절히 삭제해서 공간을 확보할 수 있도록 신경써야 합니다.

</details>

<details>
  <summary>레디스를 사용할 때 주의해야 할 점이 무엇일까요?</summary>
  <br>

레디스에 너무 많은 데이터를 저장하면 `OutOfMemoryException`이 발생할 수 있기 때문에 `TTL` 같은 것을 설정해서 제거하거나 필요 없는 데이터를 제거하면서 메모리 관리할 수 있을 것 같습니다.

</details>

<details>
  <summary>레디스가 싱글스레드여서 발생하는 문제점은 무엇이 있을까요?</summary>
  <br>

싱글스레드 이기 때문에 오래 걸리는 작업을 하는 것을 조심해야 합니다.

</details>

<details>
  <summary>레디스 샤딩이 무엇에 대해서 설명해주세요.</summary>
  <br>
</details>

<details>
  <summary>레디스 클러스터에 대해서 설명해주세요.</summary>
  <br>
</details>

<br>

## `Etc`

<details>
  <summary>데이터베이스 정규화에 대해서 설명해주세요.</summary>
  <br>

1. 1차 정규화 : 하나의 컬럼에는 하나의 값만 들어가야 한다. ,를 구분해서 값을 넣지 않음

2. 2차 정규화 : 식별자(기본키)가 여러 개 일 때 식별자(기본 키) 일부에만 종속되는 어트리뷰트는 제거해야 한다.

3. 3차 정규화 : 식별자(기본키)가 아닌 속성에 다른 속성에 종속되는 어트리뷰트가 존재하면 안된다.

4. BCNF(Boyce-Codd) 정규형

- 여러 후보 키가 존재하는 릴레이션에 해당하는 정규화 내용이다. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있다. 비주요 애트리뷰트가 후보키의 일부를 결정하는 분해하는 과정을 말한다. 
- 각 정규형은 그의 선행 정규형보다 더 엄격한 조건을 갖는다. 
- 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다. 
- 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다.
- 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다. 
- 수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것이다.

</details>

<details>
  <summary>INNER JOIN과 OUTER JOIN의 차이를 말해주세요.</summary>
  <br>

INNER 조인은 서로 교집합이 해당하는 부분만을 가져옵니다.

반면에 OUTER JOIN에는 LEFT OUTER JOIN, RIGHER OUTER JOIN이 있는데 LEFT OUTER JOIN이면 교집합 + 왼쪽에 해당하는 것들을 가져옵니다.
즉, 겹치는 것이 없더라도 NULL을 채워서 가져옵니다.

</details>

<details>
  <summary>MySQL이랑 MariaDB는 어떤 DB 엔진을 쓰는지 알고 계신가요?</summary>
  <br>

MyISAM, innoDB 대표적이고 이외에도 여러가지가 존재합니다.

</details>

<details>
  <summary>Union 과 JOIN 의 차이는 무엇인가요?</summary>
  <br>

- ### Union
  - 각 쿼리의 결과 합을 반환하는 합집합 (중복제거)
  - UNION ALL : 각 쿼리의 모든 결과를 포함한 합집합 (중복제거 안함)

- ### Join
  - Inner join (교집합)
  - Outer Join (합집합)
  
</details>

<details>
  <summary>언두 영역이란 무엇인가요?</summary>
  <br>

- 언두 영역은 UPDATE 문장이나 DELETE 문장으로 데이터를 변경했을 때 `변경되기 전의 데이터(이전 데이터)를 보관하는 곳입니다.`

</details>

<details>
  <summary>MVCC 란 무엇인가요?</summary>
  <br>

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, `MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공`하는 데 있습니다. InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경합니다. 이러한 방식을 `MVCC` 라고 합니다.

</details>

<details>
  <summary>데이터베이스 키</summary>
  <br>

- 슈퍼키 : 테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합. 슈퍼키는 `유일성`만 만족하면 슈퍼키가 될 수 있다.(`최소성`은 만족하지 않습니다.)
- 후보키 : 테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합. `유일성`, `최소성`을 동시에 만족해야 한다.
- 기본키(PK: Primary Key): 
  - 튜플을 대표하도록 선정된 후보키입니다.
  - 후보키 중에서 하나를 기본키로 선택하여 지정합니다. 
- 외래키(foreign key)
  - 특정 릴레이션의 기본키를 참조하는 속성 집합 
  - 기본키와 외래키는 릴레이션간의 연관성을 표현 
  - 의미적 연관성이 있음에도 다른 릴레이션으로 분류된 튜플 사이의 연결고리 역할

![key](https://user-images.githubusercontent.com/45676906/93320978-abb21880-f84c-11ea-8577-a8a775f7248e.png)

</details>

<details>
  <summary>복제(Replication)가 무엇인지 설명해주세요.</summary>
  <br>

![1212](https://user-images.githubusercontent.com/45676906/119230561-b64d4c00-bb57-11eb-80f0-c766d5732a39.png)

- `복제`는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술

- 일반적으로 MySQL 복제에는 INSERT, UPDATE와 같은 쿼리를 이용해 데이터를 변경할 수 있는 MySQL 서버와 SELECT 쿼리로 데이터를 읽기만 할 수 있는 MySQL 서버로 나뉜다.

- 전자를 `마스터(master) = 쓰기 작업` 후자를 `슬레이브(Slave) = 읽기 작업`라고 함

</details>

<details>
  <summary>마스터 슬레이브가 무엇인지 설명해주세요.</summary>
  <br>

### `마스터(Master)`

- MySQL의 `바이너리 로그`가 활성화되면 어떤 MySQL 서버든 마스터가 될 수 있다.
- `쓰기 전용`

<br>

### `슬레이브(Slave)`

- `마스터 서버가 바이너리 로그`를 가지고 있으면 `슬레이브 서버는 릴레이 로그`를 가지고 있다.

- `읽기 전용`

- 슬레이브 서버의 I/O 스레드는 마스터 서버에 접속해 변경 내역을 요청하고, 받아 온 변경 내역을 릴레리 로그에 기록한다. 슬레이브 서버의 SQL 스레드가 릴레이 로그에 기록된 변경 내역을 재실행 함으로써 슬레이브 데이터를 마스커와 동일한 상태로 유지함

<br>

### `슬레이브는 하나의 마스터만 설정 가능`

- MySQL 복제에는 하나의 슬레이브는 하나의 마스터만 가질 수 있다.

- 하나의 마스터에 N개의 슬레이브가 일반적인 형태

<br>

### `마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정`

- 슬레이브는 `읽기 전용`으로 하기

<br>

### `슬레이브 서버용 장비는 마스터와 동일한 사양이 적합`

- 오히려 마스터보다 슬레이브 사양이 더 좋아야 함 (자주 변경이 있는 마스터 서버라면 특히 더!)

<br>

### `복제가 불필요한 경우에는 바이너리 로그 중지`

- 바이너리 로그를 작성하기 위해 MySQL은 큰 자원을 소모함

</details>

<details>
  <summary>Scale Out vs Scale Up 이 무엇인지 설명해주세요.</summary>
  <br>

### `Scale Out`

- 기존의 서버와 같은 사양 또는 비슷한 사양의 서버 대수를 증가시키는 방법으로 처리 능력을 향샹시키는 것을 말한다. 스케일 아웃 방식을 "수평 스케일"이라고 부르기도 하고, 확장이 스케일 업보다는 다소 유연하다.
- 1’의 처리 능력을 가진 서버에 동일한 서버 4대를 더 추가하여, 총 ‘5’의 처리 능력을 만드는 것이다. 서버가 여러 대가 되기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 ‘로드밸런싱’이 필수적으로 동반되어야 한다.
- 즉, 여러 대의 서버가 분산(나누어) 처리할 수 있도록 요청을 나누어주는 서비스

<br>

### `Scale Up`

- 성능이나 용량 증강을 목적으로 하나의 서버에 디스크를 추가하거나 CPU나 메모리를 업그레이드시키는 것을 말한다. 하나의 서버의 능력을 증강하기 때문에 수직 스케일링(vertical scaling)이라고도 한다.
- 즉, 기존의 하드웨어를 보다 높은 사양으로 업그레이드하는 것을 말한다.

</details>

<details>
  <summary>바이너리 로그가 무엇인가요?</summary>
  <br>

- 바이너리 로그 파일은 데이터베이스 변경(테이블 생성, 삭제 등) 및 테이블 변경(insert, update, delete ..) 사항들이 기록되는 바이너리 형태의 파일입니다.
- 바이너리 로그의 내용을 기반으로 하여 마스터 서버에서 슬레이브 서버로 데이터를 전송하고 복제할 수 있으며, 데이터를 복원하는데 사용하기도 합니다.

</details>

<details>
  <summary>데이터베이스에서 가용성을 보장하기 위해 어떤방식을 쓰나요?</summary>
  <br>

Master, Slave 로 나눠서 Replication 할 수 있습니다.

</details>

<details>
  <summary>Master 에서 Slave 로 Replication 하면 왜 가용성이 좋아지나요?</summary>
  <br>

마스터에서 쓰기 작업을 하고, 슬레이브에서 읽기 작업을 하면서 동시성 처리 보장하면서 읽기 성능을 향상 시킬 수 있습니다.

</details>

<details>
  <summary>파티셔닝이란 무엇인가요?</summary>
  <br>

하나의 DBMS가 많은 테이블을 관리 하기 힘들어지고, 속도도 저하

=> 파티셔닝 등장

- 파티셔닝 : `큰 테이블이나 인덱스를 관리하기 쉬운 단위로 분리하는것`
- 장점
  - 특정 DML과 쿼리의 성능을 향상시키며, Data Write 환경에서 효율적이다
  - 많은 Insert가 있는 OLTP 시스템에서 특히 경합을 더 줄일 수 있다
  
</details>

<details>
  <summary>RDB vs NoSQL 차이점에 대해서 설명해주세요.</summary>
  <br>

### `RDBMS`

- `RDBMS`는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다. SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.

- 장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.

### `NOSQL`

- NOSQL은 RDBMS에 비해 `자유로운 형태`로 데이터를 저장합니다. 또한 `수평확장을 할 수 있고 분산처리를 지원`합니다. 다양한 형태의 NOSQL 데이터베이스가 있고, 대표적으로 key-value store, bigtable, dynamo, document db, graph db 등이 있습니다.

- 둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.

</details>

<details>
  <summary>공유 잠금(Shared Lock)</summary>
  <br>

공유 잠금이 설정되어 있는 동안 다른 트랜잭션이 데이터를 변경할 수 없다.
레코드나 간격을 읽을 때 다른 트랜잭션이 변경하지 못하게 하는 용도의 잠금 즉, 읽기 전용 작업

</details>

<details>
  <summary>베타적 잠금(Exclusive Lock)</summary>
  <br>

다른 트랜잭션이 읽거나 수정할 수 없다. 즉, 해당 트랜잭션에서 그 레코드나 간격을 변경하기 위해 획득해야 하는 잠금

- `공유 잠금은 내가 읽는 동안 남들이 내가 읽고 있는 데이터를 변경하거나 삭제하지 못하게 하는 장치`
- `베타적 잠금은 내가 쓰기를 하는 동안 남들이 쓰지 못하게 하는 것`

</details>

<details>
  <summary>낙관적 락이랑 비관적 락 이 무엇인지 아는지?</summary>
  <br>

### `낙관적 락(optimistic lock)`

`낙관적 락`은 이름 그대로 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법입니다. 이것은 `데이터베이스가 제공하는 락 기능을 사용하는 것이 아니라 JPA가 제공하는 버전 관리 기능을 사용합니다. 쉽게 이야기해서 애플리케이션이 제공하는 락입니다.` 낙관적 락은 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다는 특징이 있습니다.

<br>

### `비관적 락(pessimistic lock)`

이름 그대로 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법입니다. 이것은 `데이터베이스가 제공하는 락 기능`을 사용합니다. 대표적으로 `select from update` 구문이 있습니다.



</details>

<details>
  <summary>쿼리가 실행되는 순서를 설명해주세요.</summary>
  <br>

- FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY

</details>