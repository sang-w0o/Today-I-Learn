# `Java`

## `1) 추상 클래스와 인터페이스의 차이에 대해서 설명해주세요.`

```
추상 클래스는 말 그대로 클래스에 가깝고, extends 키워드를 사용합니다. 
즉, extends 키워드에 맞게 하위 클래스에게 자신의 기능을 확장해주는 것에 가깝습니다. 
대표적으로 동물 → 강아지, 고양이 등등 이러한 경우는 추상 클래스가 더 적절하다. 
지금의 예시처럼 어떤 비슷한 느낌의 계열끼리 있을 때 추상 클래스를 사용합니다

인터페이스는 클래스가 무엇을 할 수 있다라고 하는 기능을 구현하도록 강제하는 특징을 가지고 있습니다. 
그래서 인터페이스는 extends 키워드가 아니라 implements 키워드를 사용하는 것을 알 수 있습니다. 

인터페이스는 implements 라는 키워드처럼 인터페이스에 정의된 메소드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌이고, 
추상 클래스는 extends 키워드를 사용해서 자신의 기능들을 하위 클래스로 확장 시키는 느낌이라고 생각합니다.
```

<br>

## `2) SOLID 에 대해서 설명해주세요.`

> S → SRP : 단일 책임 원칙 : 어떤 클래스를 변경해야 하는 이유는 하나여야 한다.

> O → OCP : 개방 폐쇄 원칙 : 확장에는 열려있고, 변경에는 닫혀있어야 합니다. 대표적인 예시는 JDBC가 있음

> L → LSP → 리스코프 치환 원칙 : 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다. 즉, 부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 대신 사용했을 때 코드가 원래 의도대로 작동해야 한다는

> I → ISP → 인터페이스 분리 원칙 : SRP와 상당히 유사한데, 인터페이스는 자신이 사용하지 않는 메소드를 가져서는 안된다.

> D → DIP → 의존 역전 원칙 : 추상 적인 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상적인 것에 의존해야 한다.

<br>

## `3) final 키워드가 클래스, 필드 메소드에 붙었을 때를 설명해주세요.`

> 메소드 final : 오버라이딩이 불가능한 메소드가 됩니다.

> 클래스 final : 다른 클래스의 조상이 될 수 없습니다.

> 필드 final : 초기화가 한번만 가능합니다.

<br>

## `4) equals로 재정의 한다면 hashCode도 재정의 해야 하는 이유는?`

```
Object 규약에 equals가 true 라면 hashCode 값도 같아야 한다는 규약이 있습니다. 이러한 이유는 만약에 A 클래스에 equals만 오버라이딩 해서 필드의 값들이 같다면 true 라고 했다고 가정하겠습니다. 
그러면 그 때 HashMap을 사용한다면 Key(class), Value(값) 으로 저장한 후에 다시 get 해온다면 null을 출력하게 될 것입니다. 
왜냐하면 HashMap은 해시 코드 기반으로 하기에 다른 버킷에 존재하기 때문입니다.
```

<br>

### `5) HashMap 의 충돌 과정과 Java 8에서 어떻게 하고 있는지 설명해주세요.`

```
Hash 충돌에는 '개방 주소법', '분리 연결법'이 존재합니다. 
자바 Hash는 분리 연결법을 사용하고 있습니다. 해시 버킷에 충돌이 일어날 때마다 옆으로 LinkedList 형태로 저장하는 것을 말하는데요. 
이렇게 저장해서 길이가 8이 되면 리스트 → 트리로 변경이 됩니다. 
그리고 다시 6개 이하가 되면 트리 → 리스트 형태로 바뀝니다.
```

Reference: [https://d2.naver.com/helloworld/831311](https://d2.naver.com/helloworld/831311)

<br>

## `6) HashMap과 HashTable의 차이에 대해서 설명해주세요.`

> HashTable은 싱크로나이즈드가 붙어 있어서 Thread-Safe 하다는 특징이 있으며 아주 예전부터 있던 클래스가 현재는 잘 관리되지 않는 클래스임 + Key에 null을 허용하지 않음

> HashMap은 Thread-Safe 하지 않다는 특징을 가지고 있음 + null을 허용함

<br>

## `ConcurrentHashMap 이 무엇인지 설명해주세요.`

HashMap 은 멀티 스레드 환경에서 사용할 수 없는 클래스입니다. HashTable 은 멀티스레드 환경에서 사용할 수 있지만 너무 예전에 나온 클래스이고 단점에 대한 보완을 하고 있는 클래스도 아닙니다. 그래서 HashMap 의 멀티스레드에서 사용할 수 없다는 단점을 보완하는 클래스가 ConcurrentHashMap 입니다. 

ConcurrentHashMap 은 `put` 작업을 할 때 메소드 전체에 `Synchronized`가 붙어있지 않다는 특징이 있습니다. 그리고 `Lock`을 버킷 마다 가지고 있어 같은 버킷에 대해서 쓰는 것이 아니라면 여러 쓰레드에서도 동시에 쓰기 작업을 할 수 있습니다. 

즉, ConcurrentHashMap은 멀티 쓰레드 환경에서 읽기 작업보다 쓰기 작업이 많을 때 사용하면 좋습니다.

<br>

## `7) StringBuilder vs StringBuffer 차이를 설명해주세요.`

> 두 클래스는 완전히 동일한데 하나의 차이만 존재합니다. StringBuilder는 Thread-Safe 하지 않고, StringBuffer는 Thread-Safe 합니다.  String 클래스는 불변 클래스입니다. 즉 값이 매번 바뀌면 새로 메모리를 할당해서 얻습니다.
> String 도 불변 클래스입니다. 

<br>

## `8) ArrayList vs LinkedList 차이를 설명해주세요.`

```
ArrayList는 동적 배열과 비슷합니다. 크기를 지정하지 않고 ArrayList를 만들면 크기 10의 배열로 만들게 됩니다. 
배열의 특징이다 보니 검색을 할 때 O(1)로 가져올 수 있고 끝에서 추가하고 삭제하는 것도 O(1)로 할 수 있습니다. 
하지만 앞이나 중간에 삽입 삭제를 했을 때는 나머지 원소들을 다 땡겨야 한다는 큰 단점을 가지고 있습니다.  

반면에 LinkedList는 불연속적으로 있는 데이터들을 연결한 형태입니다. 즉, 데이터를 삽입, 삭제 하는 것은 쉽습니다. 
하지만 검색에는 ArrayList 보다 상대적으로 느리다는 것을 알 수 있습니다.
```

<br>

## `9) 다형성이란 무엇인가요?`

> 다형성(polymorphism)이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다.

> List<Integer> list = new ArrayList<>();

> 대표적으로 위와 같이 사용할 수 있습니다.

<br>

### `10) 오버로딩과 오버라이딩 차이가 무엇인가요?`

```
> 오버로딩: 메소드의 이름은 같지만 파라미터 형태만 다름

> 오버라이딩: 메소드의 이름 파라미터 다 같지만 내부 구현체만 재정의해서 사용하는 것
```

<br>

### `11) 접근 제어자에 대해서 설명해주세요.`

```
> public: 어디에서나 접근이 가능함

> protected: 현재 클래스, 자식 클래스에서 까지만 접근 가능함 

> default: 같은 패키지에서만 접근 가능

> private: 같은 클래스 내부에서만 접근 가능함
```

<br>

## `12) 직렬화가 무엇인가요?`

```
자바 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 
바이트(byte) 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러서 이야기합니다.
```

<br>

## `직렬화가 사용되는 곳`

- Servlet Session
- Cache (EhCache, Redis, MemCached)
- 자바 RMI

<br>

## `직렬화 장단점`

- 장점: 자바 시스템에 최적화 되어 있다. 복잡한 데이터 구조여도 몇 개만 잘 설정 하면 쉽게 직렬화를 적용할 수 있다.
- 단점: 사소한 거 하나만 틀려도 직렬화가 안되기 때문에 에러를 발생시킬 위험이 크고 지뢰 시스템이 될 수 있음. 용량도 무거워서 용량이 민감하다면 JSON, XML 같은 것을 사용하는 것이 좋다.

<br>

## `13) Checked Exception vs UnChecked Exception 차이가 무엇인가요?`

```
`RuntimeException`의 하위 클래스들이 `Uncheck Exception` 이라 하고 RuntimeException의 하위 클래스가 아닌 Exception 클래스의 하위 클래스들을 `Checked Exception`이라고 합니다.

체크 예외는 RuntimeException의 하위 클래스가 아니면서 Exception 클래스의 하위 클래스들입니다. `체크 예외의 특징은 반드시 에러 처리를 해야하는 특징(try/catch or throw)`을 가지고 있습니다.

언체크 예외는 RuntimeException의 하위 클래스들을 의미합니다. 이것은 체크 예외와는 달리 에러 처리를 강제하지 않습니다.
```

<br> 

## `14) Collection 인터페이스 하위 인터페이스를 말해주세요.`

- List
  - ArrayList, LinkedList
- Queue
  - LinkedList
- Set
  - HashSet, LinkedHashSet, TreeSet
  
<br>

## `12) Kotlin과 Java의 차이점 느낀대로 말해주세요.`

1. 코틀린 주 생성자 사용 방식
2. NULL 가능 여부
3. Data Class를 사용하면 `Equals`, `toString` 같은 것들을 자동으로 만들어줌
4. 코틀린의 val, var
5. 코틀린은 기본이 final class
6. 코틀린 파라미터 디폴트 값 설정 가능
7. 확장 함수

<br>

## `13. Java 8에 추가된 것들에 대해서 설명해주세요.`

- Date -> LocalDateTime, LocalDate 등장
- Lambda, Stream 생성
- Interface Default Method 생성
- JVM Permanet 삭제

<br>

## `14. equals vs hashCode vs == 차이점이 무엇인가요?`

- equals: 객체가 가지는 필드들이 같은 값을 가지는지 확인하는 메소드
- hashCode: 객체가 같은 메모리 주소에 저장되어 있는지 확인하는 메소드
- == : 객체가 저장된 메모리 주소가 같은지 판단

<br> 

## `15. 프로세스 vs 쓰레드 차이점에 대해서 설명해주세요.`

- 프로세스는 운영체제로부터 자원을 할당받습니다. 즉, 프로그램이 메모리에 올라간 상태를 의미합니다.
- 스레드는 프로세스로부터 자원을 할당받고, 프로세스의 코드/데이터/힙영역을 공유하기 때문에 좀 더 효율적으로 통신할 수 있습니다. 또한 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠릅니다. 그리고, 스레드는 자원 공유로 인해 문제가 발생할 수 있으니 이를 염두에 둔 프로그래밍을 해야합니다.

<br>

## `16. Stream map vs FlatMap 차이점에 대해서 설명해주세요.`

- `map`: map()은 데이터를 특정 데이터로 변환하는데 사용됩니다. 스트림의 요소에 저장된 값 중에서 원하는 필드만 뽑아내거나 특정 형태로 변환해야 할 때가 있다. 
- `flatmap`: flatMap()은 Array나 Object로 감싸져 있는 모든 원소를 단일 원소 스트림으로 반환합니다.

<br>

