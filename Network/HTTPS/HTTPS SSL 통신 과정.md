## `HTTPS 생각 정리하기`

이번 글에서는 `HTTPS`의 `SSL 통신 과정`에 대해서 정리해보겠습니다.

`SSL 통신` 과정을 이해하기 위해서는 먼저 `대칭키(공통키)` 방식과 `비대칭키(공개키)`가 무엇인지 알고 있어야 합니다. 

<br>

## `대칭키(공통키)`

`대칭키`는 `공통키` 라고도 불립니다. `대칭키(공통키)`는 이름에서 알 수 있듯이 양쪽에서 `복호화`, `암호화` 하는데 같은 키를 사용하는 것입니다. 

예를들어, `A`라는 `공통키`가 존재한다고 가정하겠습니다. 그리고 `클라이언트 - 서버`가 통신을 하는 상황에서 클라이언트에서 서버로 데이터를 전송할 때 `공통키 A`로 데이터를 암호화해서 `서버`로 전송할 수 있습니다. 서버 입장에서는 클라이언트가 보낸 암호화된 데이터를 `공통키 A`로 다시 `복호화` 할 수 있습니다. 

그런데 `대칭키(공통키)` 방식은 한 가지 `치명적인` 단점이 존재합니다. 단점은 `최초의 통신 한번은 공통키 A를 통신하는 과정이 필요하다는 것` 입니다. 최초의 통신 과정에서 `공통키 A`를 탈취 당한다면 누구나 `암호화한 데이터를 볼 수 있다는` 것 때문에 안전하지 못하다는 단점을 가지고 있습니다.

그래서 나온 것이 `비대칭키(공개키)` 방식입니다. 

<br>

## `비대칭키(공개키)`

`비대칭키(공개키)` 방식은 `공개키(누구나 볼 수 있는 키)`와 `비밀키(노출되면 안되는 키)`를 사용해서 `암호화`, `복호화`를 하는 방식입니다. 즉, `공개키`를 통해서 `암호화`를 하면 `비밀키`를 통해서만 `복호화` 할 수 있다는 특징이 있습니다. 

다시 말하자면, `공개키 - 비밀키`는 하나의 쌍이라서 `A`가 가지고 있는 `공개키`로 복호화 했다면 A가 가지고 있는 `비밀키` 로만 `복호화`를 할 수 있습니다. (참고로 A가 가지고 있는 `비밀키`로 `암호화`한 것을 `A`가 가지고 있는 `공개키`로 `복호화`할 수도 있습니다.)

`클라이언트 - 서버`가 통신하는 과정으로 예시를 들어보겠습니다. `클라이언트`에서 `서버`로 데이터를 보낼 때는 `서버의 공개키로 데이터를 암호화` 하여 전송합니다. 서버에서는 `자신의 비밀키를 사용하여 데이터를 복호화` 하는 것입니다.

이러한 방식으로 `대칭키(공통키)` 방식의 단점을 해결하여 안전하게 통신할 수 있습니다. 하지만 `비대칭키(공개키)` 방식도 하나의 단점이 존재합니다. 단점은 `비대칭키(공개키)` 방식은 통신할 때마다 `암호화`, `복호화` 과정이 필요하기 때문에 `컴퓨터에 많은 부하를 준다는 단점`을 가지고 있습니다.

이러한 단점을 보완하여 `SSL 통신`에서는 `대칭키(공통키) + 비대칭키(공개키) 방식을 섞어서 사용`하고 있습니다.

<br>

## `대칭키(공통키) + 비대칭키(공개키)`

`대칭키(공통키)`는 통신하는 과정에 부하가 적다는 장점과 최초 통신할 때의 `공통키`가 탈취당할 수 있다는 단점을 가지고 있습니다. `비대칭키(공개키)` 방식은 `키를 탈취당하지 않고 안전하게 통신할 수 있다는` 장점과 `통신할 때마다 암호화, 복호화하는 과정 때문에 컴퓨터에 부하를 줄 수 있다는` 단점이 존재합니다.

`최초 통신할 때는 비대칭키(공개키)` 방식을 사용하고 `데이터를 암호화, 복호화하는 통신을 할 때는 대칭키(공통키)` 방식을 사용하는 것입니다.

이렇게 두 방식의 장점을 이용해서 통신한다면 `노출되면 안되는 키`를 탈취 당할 일도 없고, 서버에 부하를 주는 작업도 작아 안전하고 효율적으로 통신할 수 있다는 장점이 있습니다.

그런데 여기서 또 하나의 궁금증이 생기는데요. 클라이언트 - 서버의 최초의 통신 과정에서 `비대칭키(공개키)` 방식을 사용하려면 클라이언트는 서버의 `공통키`를 알아야 하는데요. `서버의 공통키는 어떻게 얻을 수 있을까요?` 그리고 가장 중요한 것은 `해당 공개키가 제가 통신하고자 하는 서버의 진짜 공개키인지 어떻게 알 수 있을까요?`

이 문제를 해결하는데 `인증 기관(CA:Certificate Authority)`에서 발행하는 `공개키 증명서`가 이용되고 있습니다. 인증 기관은 아무나 할 수 있는 것이 아니라 엄격한 심사의 과정을 거치게 됩니다. 즉, 서버, 클라이언트가 모두 신뢰할 수 있는 제 3자 기관입니다.

이 문제를 어떻게 해결했는지를 알려면 `서버에서 CA로 부터 인증서를 발급 받는 과정`, `SSL HandShake 과정` 2가지를 알아야 하는데요. 하나씩 알아보면서 이해해보겠습니다. 

<br>

## `서버에서 CA로 부터 인증서를 발급 받는 과정`

1. 먼저 서버에서 인증 기관에 `서버 공개키`를 제출합니다.
2. 인증 기간은 `서버로부터 제출된 공개키를 자신의 비밀키를 통해 암호화` 한 후에 합니다. 
3. 인증기관이 발급한 인증서에 2번에서 암호화한 서버의 공개키를 인증서에 담아서 서버에게 보내줍니다. 
4. 서버는 이 인증 기관에 비밀키로 암호화된 자신의(서버의) 공개키를 담은 인증서를 클라이언트에게 보냅니다. 
5. 인증서를 받은 클라이언트는 `인증 기관 CA의 공개키`를 사용해서 서버의 공개키를 복호화 합니다. 이 때 복호화가 잘 된다면 인증 기관이 발급한 인증서라는 것과 실제 서버의 공개키라는 것을 알 수 있습니다.(즉, 신뢰할 수 있습니다.)

<br>

여기서 4번의 과정을 보면 클라이언트는 CA 기관의 비밀키로 암호화 되어 있는 서버의 공개키가 담긴 인증서를 받게 됩니다. 인증서에 들어있는 서버의 공개키를 복호화 하기 위해서는 CA의 공개키가 필요합니다. 그러면 어떻게 CA 기관의 공개키를 클라이언트에게 전달할 수 있을까요?

통신 중에는 어떤 방법을 사용하더라도 안전하게 전달하는 것은 어렵기 때문에 많은 브라우저가 주요 인증 기관의 공개키를 사전에 내장한 상태로 제품을 내놓고 있습니다. 다음으로는 `SSL HandShake`는 어떠한 과정으로 이루어지는지 알아보겠습니다.

<br>

## `SSL Handshake 과정 이해하기`

`TCP 3-way-Handshake` 과정 이후에 `SSL Handshake`가 진행됩니다. 

![1212](https://user-images.githubusercontent.com/45676906/155833930-fd75a8c4-a229-4c89-8d20-3e7dc4e9eaa8.png)

1. 클라이언트가 `Client Hello 메세지(랜덤 메세지)`를 서버에게 보내면서 SSL 통신을 시작합니다. 메세지에는 클라이언트가 어떤 암호 알고리즘을 사용할 수 있는지 등등이 포함되어 있습니다. 
2. 서버가 SSL 통신이 가능한 경우에는 `Server Hello 메세지(랜덤 메세지)`로 응답합니다. 클라이언트가 보낸 암호 알고리즘 중에 가능한 알고리즘을 하나 선택해 클라이언트에게 응답해줍니다. 그리고 `서버가 Certificate(인증서)를 클라이언트에게 전송합니다` 즉, 신뢰성 있는 CA 기관으로 부터 발급 받은 증명서를 클라이언트에게 보내게 됩니다.
3. 클라이언트는 서버로부터 받은 증명서를 브라우저에 내장되어 있는 인증 기관의 공개키로 검증하고, `인증서가 진짜 CA 기간으로 부터 발급 받은 것`인지 확인합니다. 여기서 `인증서 안에 들어있는 CA 기관의 비밀키로 암호화 되어있는 서버의 공개키를 복호화하여 서버의 공개키를 클라이언트에서 얻을 수 있습니다.`
4. 서버가 Server Hello Done 메세지를 송신하고 최초의 SSL 통신이 끝났음을 통지합니다. 
5. 클라이언트는 클라이언트에서 서버로 보낸 `Client Hello(랜덤 메세지)`와 `서버에서 클라이언트로 응답한 Sever Hello(랜덤 메세지)`를 조합하여 `Pre-Master-Secret-Key`를 만듭니다.(`Pre-Mster-Secret-Key`는 클라이언트와 서버 사이에 `공통키`로 사용될 키이기 때문에 절대로 외부로 노출되어서는 안됩니다.)
6. 클라이언트는 `증명서에 들어있던 서버의 공개키를 이용해서 Pre-Master Secret Key를 암호화` 한 후에 서버로 보냅니다.(`Pre-Master-Secret-Key`는 외부에 노출되면 안되기 때문에 이 과정에서 `비대칭키(공개키)` 방식으로 통신하게 됩니다.) 
7. 서버는 자신의 공개키로 암호화 되어 있는 `Pre-Master-Secret-Key`를 `자신의 비밀키`로 `복호화`한 후에 클라이언트와 서버에서 사용할 `공통키`를 가지게 됩니다.
8. 클라이언트와 서버는 모두 `Pre-Master-Secret-Key`라는 `공통키`를 가졌기 때문에 이후 통신에는 `대칭키(공통키)` 방식으로 사용해서 통신하게 됩니다.

<br>

## `인증기관 CA는 인증서를 왜 자신의 비밀키로 암호화 할까?`

인증기관 CA가 자신의 비밀키로 인증서를 암호화하여야 해당 인증서가 자기가(CA) 발급한 것이라는 것을 증명할 수 있기 때문입니다.

즉, CA의 비밀키로 인증서를 암호화한 것은 CA의 공개키로 복호화할 수 있습니다. 다시 말해, CA 공개키로 복호화가 된다면 CA가 발급한 인증서라는 것을 알 수 있습니다.

`CA`에서 발급한 인증서라는 것을 증명하기 위해 CA 기관만 알고 있는 자신의 비밀키를 사용해서 증명서를 암호화하는 것입니다. 

<br> <br>

## `Reference`

- [얄팍한 코딩사전 HTTPS란 무엇일까?](https://www.youtube.com/watch?v=H6lpFRpyl14)
- [생활코딩 SSL 통신 과정](https://www.youtube.com/watch?v=8R0FUF_t_zk)