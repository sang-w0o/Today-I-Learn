# `TCP와 UDP의 구조 정리`

이번 글에서는 먼저 `신뢰성/정확성`을 우선으로 하는 `연결형 통신` 프로토콜인 `TCP`에 대해 알아보겠습니다. 

![스크린샷 2021-04-01 오전 9 55 41](https://user-images.githubusercontent.com/45676906/113228711-6cbb5000-92d0-11eb-83c7-4a0afb40754c.png)

`캡슐화`, `역캡슐화`에 대해서 알고 있을 것입니다.  

- `캡슐화: 응용 계층부터 물리 계층까지 계층별로 데이터를 전달할 때 헤더를 붙이는 것입니다.`
- `역캡슐화: 물리 계층부터 응용 계층까지 계층별로 데이터를 전달할 때 헤더를 제거하는 것입니다.`

이 중에서 `TCP`로 전송할 때 붙이는 헤더를 `TCP 헤더`라고 하고, 이 TCP 헤더가 붙은 데이터를 `세그먼트(segment)`라고 합니다. 

![tcp](https://yohanpro.com/media/images/network/TCP/header.png)

TCP 헤더에 목적지까지 데이터를 제대로 전송하기 위해 필요한 정보를 가지고 있습니다. TCP는 연결형 통신에 사용되는 프로토콜이라고 설명했습니다.

연결형 통신은 꼼꼼하게 상대방을 확인하면서 데이터를 전송합니다. `데이터를 전송하려면 먼저 연결(connection)이라는 가상의 독점 통신로를 확보해야 합니다.`

<br>

### `어떻게 연결을 확립할 수 있을까요?`

![connection](https://yohanpro.com/media/images/network/TCP/codeBeat.png)

위의 `코드 비트`부분을 보면 TCP 헤더의 107~112번째 비트까지의 6비트로 연결의 제어 정보가 기록되어 있습니다. 각 코드 비트에는 `연결의 제어 정보가 기록됩니다.`

각 비트별로 역할이 있습니다. 모두 초기값은 0이고, 비트가 활성화되면 1이 됩니다. 이 중에서 `연결을 학립하려면 SYN과 ACK`가 있어야 합니다. 

- `SYN: 연결 요청`
- `ACK: 확인 응답`

이렇게 요청-응답을 통해 연결을 확립하는 과정을 이해하려면 `3-way 핸드세이크`라는 것을 알아야 합니다. 

<br>

### `3-way 핸드쉐이크`

![three](https://yohanpro.com/media/images/network/TCP/3-way.png)

위의 그림과 같이 `연결(connection)`은 `SYN`과 `ACK`를 사용하여 확릴할 수 있습니다. 

1. 통신을 하려면 컴퓨터 2에게 허가를 받아야 하므로, 컴퓨터 1에서 컴퓨터 2로 연결 확립 허가를 받기 위한 요청(SYN)을 보냅니다. 
2. 컴퓨터 2는 컴퓨터 1이 보낸 요청을 받은 후에 허가한다는 응답을 회산하기 위해 연결 확립 응답(ACK)을 보냅니다. 동시에 컴퓨터 2도 컴퓨터 1에게 데이터 전송 허가를 받기 위해 연결 확립 요청(SYN)을 보냅니다.
3. 컴퓨터 2의 요청을 받은 컴퓨터 1은 컴퓨터 2로 허가한다는 응답으로 연결 확립 응답(ACK)을 보냅니다. 

이 때 연결 확립을 위해 코드 비트의 `SYN`과 `ACK`가 1로 활성화 됩니다. 이와 같이 `3-way 핸드쉐이크는 데이터를 보내기 전에 연결을 확립하기 위해 패킷 요청을 세번 교환하는 것`을 의미합니다. 

<br>

### `데이터 전송한 후에는 연결을 끊기 위한 요청을 교환해야 합니다.`

연결을 끊을 때는 `FIN`, `ACK`를 사용합니다. `FIN`은 연결 종료를 뜻합니다. 

![dis](https://yohanpro.com/media/images/network/TCP/FIN.png)

1. 컴퓨터 1에서 컴퓨터 2로 연결 종료 요청(FIN)을 보냅니다.
2. 컴퓨터 2에서 컴퓨터 1로 연결 종료 응답(ACK)을 반환합니다. 
3. 또한 컴퓨터 2에서도 컴퓨터 1로 연결 종료 요청(FIN)을 보냅니다.
4. 컴퓨터 1에서 컴퓨터 2로 연결 종료 응답(ACK)을 반환합니다. 

<br>

## `일련번호와 확인 응답 번호의 구조`

3-way 핸드세이크가 끝나고 실제 데이터를 보내거나 받을 때는 아래의 그림과 같이 TCP 헤더의 `일련번호(sequence number)`, `확인 응답 번호(acknowledgement number)`를 사용합니다. 

![three](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fct2Feo%2FbtqubfWBac0%2FSosC8IzXULi4uXtbI25Kz1%2Fimg.png)

- `일련번호`: TCP는 데이터를 분할해서 보내는데 일련번호는 송신 측에서 수신 측에 이 데이터가 몇 번째 데이터인지 알려주는 역할을 합니다. 
- `확인 응답 번호`: 수신 측이 몇 번째 데이터를 수신했는지 송신 측에 알려주는 역할을 합니다. (예를 들어, 10번 데이터를 받았으면 11번 데이터를 달라고 요청)

![스크린샷 2021-04-01 오전 9 14 56](https://user-images.githubusercontent.com/45676906/113226288-bbfe8200-92ca-11eb-9f61-1a692f9d83b0.png)

위 그림의 데이터를 전송하기 전 단계에서 3-way 핸드셰이크로 연결 수립이 이루어질 때, 이번 통신에 사용되는 일련번호인 3001과 확인 응답 번호인 4001이 결정됩니다. 

1. 컴퓨터 1은 컴퓨터 2로 200바이트의 데이터를 전송합니다. 
2. 컴퓨터 2는 200바이트를 수신하고 다음에 수신하고자 하는 데이터 번호를 확인 응답 번호에 넣습니다. 다음에 수신하고자 하는 데이터는 3001 + 200 = 3201이므로 3201번부터 보내 달라고 요청합니다. 
3. 컴퓨터 1은 컴퓨터 2로 3201번부터 200바이트의 데이터를 전송합니다. 

TCP는 데이터 전송이 완료될 때까지 이러한 과정을 반복하게 됩니다. 데이터가 항상 올바르게 전송되는 것이 아니므로 `일련번호와 확인 응답 번호를 사용해서 데이터가 손상되거나 유실된 경우에 데이터를 재전송하게 되어 있습니다.` 이를 `재전송 제어`라고 합니다.

데이터를 전송하는 도중에 오류가 발생하면 일정 시간 동안 대기한 후에 재전송하는 것입니다. 

<br>

## `윈도우 크기란?`

지금까지 봤던 것은 `세그먼트` 하나를 보낼 때마다 확인 응답을 한 번 반환하는 통신이었습니다. 이와 같은 통신은 효율이 좋지 않습니다. 
그래서 세그먼트를 연속해서 보내고 난 다음에 확인 응답을 반환하면 효율이 높아집니다. 그래서 보통 받은 세그먼트를 일시적으로 `버퍼`에 보관합니다. 

이 버퍼 덕에 세그먼트를 연속해서 보내도 수신 측은 대응할 수 있고 확인 응답의 효율도 높아집니다. 

<br>

### `수신 측이 세그먼트를 대량으로 받아서 처리하지 못하면 어떻게 될까요?`

수신 측은 대량으로 데이터가 전송되면 보관하지 못하고 넘쳐 버립니다. 이것은 `오버플로(overflow)`라고 합니다. 그래서 오버플로가 나지 않도록 `버퍼의 한계 크기`를 알고 있어야 합니다. 
그것이 TCP 헤더의 `윈도우 크기(window size)`라는 값 입니다. (위의 그림에서 볼 수 있습니다.) 

- `윈도우 크기`: `얼마나 많은 용량의 데이터를 저장해 둘 수 있는지`를 나타내는 것입니다. (즉, 확인 응답을 일일이 하지 않고 연속해서 송수신할 수 있는 데이터 크기입니다.)

윈도우 크기의 초기 값은 `3-way 핸드셰이크`를 할 때 판단합니다. 

![스크린샷 2021-04-01 오전 9 40 50](https://user-images.githubusercontent.com/45676906/113227735-59a78080-92ce-11eb-8b5a-a81add93c753.png)

위와 같이 3-way 핸드셰이크를 할 때 서로의 윈도우 크기 값을 알고 있어서 `세그먼트를 오브플로되지 않도록 보내면 되는 것입니다.`

![스크린샷 2021-04-01 오전 9 42 36](https://user-images.githubusercontent.com/45676906/113227855-996e6800-92ce-11eb-950f-78f24db6b7bf.png)

원래는 위와 같이 하나 보내고 확인 응답 받는 식으로 진행했습니다. 하지만 이제는 서로의 윈도우 크기를 알고 버퍼를 사용하기에 아래와 같이 통신할 수 있습니다. 

![스크린샷 2021-04-01 오전 9 42 53](https://user-images.githubusercontent.com/45676906/113227878-a2f7d000-92ce-11eb-8c60-e3e8315007c2.png)

<br>

## `포트 번호의 구조`

위에서 `연결 확립, 재전송 제어, 윈도우 제어`에 대해서 알아보았습니다. 전송 계층에는 이외에는 한 가지 역할이 더 있습니다. 전송된 데이터의 목적지가 어떤 애플리케이션인지 구분하는 역할도 있었습니다.

이번에는 데이터의 목적지가 어떤 프로그램인지 구분하는 역할을 하는 `포트 번호`에 대해서 알아보겠습니다.

![three](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fct2Feo%2FbtqubfWBac0%2FSosC8IzXULi4uXtbI25Kz1%2Fimg.png)

TCP 헤더의 그림을 다시 한번 보겠습니다. 위를 보면 `출발지 포트 번호(Source Port)`, `목적지 포트 번호(Destination port number)`가 존재하는 것을 볼 수 있습니다. 이와 같이 TCP 헤더에 포트 번호가 존재하기 떄문에
애플리케이션을 구분할 수 있는 것입니다. 

즉, 간단하게 예를들면 포트번호를 사용해서 `웹 브라우저`인지 `메일 프로그램`인지 구분하는 것입니다. 그리고 포트번호는 0~65535번을 사용할 수 있습니다.

- `0 ~ 1023번`: 잘 알려진 포트(well-known ports)
- `1024번`: 예약되어 있지만 사용되지는 않는 포트
- `1025번 이상`: 랜덤 포트라고 해서 클라이언트 측의 송신 포트로 사용됩니다. 

포트번호를 모르면 택배 배송을 할 때 아파트에는 도착했지만 몇 동 몇호인지는 찾을 수 없는 상황이라고 생각하면 좋습니다. 

| 애플리케이션 | 포트 번호 |
|------|---|
| SSH | 22 |
| SMTP | 25 |
| DNS | 53 |
| HTTP | 80 |
| POP3 | 110 |
| HTTPS | 443 |

이처럼 동작하는 애플리케이션은 각각 포트 번호가 있어서 다른 애플리케이션과 서로 구분됩니다. 데이터를 전송할 떄는 상대방의 IP 주소가 필요하지만, 어떤 애플리케이션이 사용되고 있는지 구분하려면 TCP는 포트 번호가 필요합니다. 

<br>

## `UDP의 구조`

전송 계층에서 `효율적`으로 통신할 수 있도록 돕는 UDP 프로토콜의 구조에 대해 알아보겠습니다. UDP는 TCP와는 다르게 `비연결형 통신`이기 때문에 데이터를 전송할 때 TCP처럼 시간이 걸리는 확인 작업을 일일이 하지 않습니다. 

UDP는 TCP와 달리 효율성을 중요하게 여기는 프로토콜이라 TCP와 같은 신뢰성과 정확성을 요구하게 되면 효율이 떨어집니다. UDP의 장점은 `데이터를 효율적으로 빠르게 보내는 것`이라서 스트리밍 방식으로 전송하는 동영상 서비스와 같은 곳에 사용됩니다. 
`그래서 동영상 같은 것 대게 빠른 UDP를 사용합니다.`

<br>

### `UDP 헤더란?`

![스크린샷 2021-04-01 오전 10 28 18](https://user-images.githubusercontent.com/45676906/113230900-fbca6700-92d4-11eb-8c98-2d981f23331f.png)

UDP 헤더가 붙은 데이터를 `UDP 데이터그램` 이라고 합니다. UDP는 `효율성과 빠른 속도가 중요해서 상대방을 확인하지 않고 연속해서 데이터를 보내기에` 헤더의 정보는 이정도로 충분합니다. 

![udp](https://mblogthumb-phinf.pstatic.net/MjAyMDA1MjVfMTY4/MDAxNTkwNDA5MzY4MzE3.jvYb3KC28Bt-nyy4yLHRgI4ArTgv6a8UDUMCRfj-mesg.sK-dsVE-jLgze_99Ckq5be4bFi2pNlJCciPZIdlStLIg.PNG.good_ray/%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.png?type=w800)

이렇게 이번 글에서는 전송 계층에서 엄청 중요한 `TCP`와 `UDP`에 대해서 살펴보았습니다. 많이 중요한 부분이니 제대로 익혀두는 것을 추천드립니다.  

