## `12장: 채팅 시스템 설계`

- 응답지연이 낮은 일대일 채팅 기능
- 최대 100명까지 참여할 수 있는 그룹 채팅 기능
- 사용자의 접속상태 표시 기능
- 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림

<br>

## `개략적 설계안 제시 및 동의 구하기`

- 클라이언트들로부터 메세지 수신
- 메세지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메세지 보관

<br>

![스크린샷 2022-03-21 오후 10 11 41](https://user-images.githubusercontent.com/45676906/159267841-f82978f0-c80f-4b45-a4f1-e41ddad7d325.png)

채팅 서비스의 경우 어떤 `통신 프로토콜`을 사용할 것인가도 중요한 문제다. 송신 클라이언트는 수신 클라이언트에게 메세지를 보낼 때 HTTP 프로토콜을 사용한다. 채팅 서비스와의 접속에는 `keep-alive` 헤더를 사용하면 효율적인데, 클라이언트와 서버 사이의 연결을 끊지 않고 계속 유지할 수 있어서다. TCP 접속 과정에서 발생하는 핸드셰이크 횟수를 줄일 수 있기 때문도 있다.

하지만 메세지 수신 시나리오는 좀 더 복잡하다. HTTP는 클라이언트가 연결을 만드는 프로토콜이며, 서버에서 클라이언트로 임의 시점에 메세지를 보내는 데는 쉽게 쓰일 수 없다. 서버가 연결을 만드는 것처럼 동작할 수 있도록 하기 위해 많은 기법이 제안되어 왔는데, `폴링(polling`, `롱 폴링(long poll-ing)`, `웹소켓(websocket)` 등이 그런 기술이다.

