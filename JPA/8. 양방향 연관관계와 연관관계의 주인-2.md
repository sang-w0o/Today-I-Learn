# `양방향 연관관계와 연관관계의 주인 2편`

## `양방향 매핑시 가장 많이하는 실수`

[저번 글]() 에서 `연관관계 주인`이라는 주제로 알아보았습니다. 이번 글에서도 연관관계 주인을 설정하면서 JPA에서 가장 많이 하는 실수에 대해서 알아보겠습니다. 

```java
public class JpaMain {

    public static void main(String[]  args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();

        EntityTransaction tx = em.getTransaction();
        tx.begin();

        try {
            Member member = new Member();
            member.setUsername("Gyunny");
            em.persist(member);

            Team team = new Team();
            team.setName("TeamA");
            team.getMembers().add(member);
            em.persist(team);

            em.flush();
            em.clear();

            tx.commit();
        } catch (Exception e) {
            tx.rollback();
        } finally {
            em.close();
        }

        emf.close();

    }
}
```

위와 같이 Member와 Team 사이의 관계는 `다대일` 인 상황이고, 연관관계의 주인이 아닌 Team에 존재하는 List<Member> 필드에다 값을 넣었을 때 DB에는 어떻게 값이 들어가는지 알아보겠습니다. 

위의 코드를 실행하고 DB를 확인해보겠습니다. 

<br>

<img width="263" alt="스크린샷 2021-07-16 오후 4 50 41" src="https://user-images.githubusercontent.com/45676906/125912359-a0f40296-ee78-4839-9a3a-c43075110590.png">

Member 테이블의 외래키인 `TEAM_ID`에는 null이 들어가 있는 것을 볼 수 있습니다. null이 들어간 이유는 무엇일까요? 

```java
@Entity
public class Team {

    @Id
    @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
}
```

팀 엔티티에 존재하는 Member 필드는 `mappedBy`로 읽기 전용이기 때문에 null이 출력되는 것입니다. 즉, 쓰기 작업을 하기 위해서는 `연관 관계 주인`의 필드에다가 쓰기 작업을 해야 합니다. 

<br>

```java
public class JpaMain {

    public static void main(String[]  args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
        EntityManager em = emf.createEntityManager();

        EntityTransaction tx = em.getTransaction();
        tx.begin();

        try {

            Team team = new Team();
            team.setName("TeamA");
            //team.getMembers().add(member);
            em.persist(team);

            Member member = new Member();
            member.setUsername("Gyunny");
            member.setTeam(team);   // 연관 관계 주인에다가 값을 넣음
            em.persist(member);

            em.flush();
            em.clear();

            tx.commit();
        } catch (Exception e) {
            tx.rollback();
        } finally {
            em.close();
        }

        emf.close();

    }
}
```

이번에는 위와 같이 연관관계의 주인인 Member 엔티티가 가지고 있는 Team 필드에다가 값을 넣고 다시 실행시켜보았습니다. 

<img width="261" alt="스크린샷 2021-07-16 오후 4 57 24" src="https://user-images.githubusercontent.com/45676906/125913102-1e6ec182-05bf-427b-aaae-57f41d989f0f.png">

이번에는 `TEAM_ID`에 값이 잘 들어간 것을 볼 수 있습니다. 즉, `연관 관계의 주인`에서 `쓰기 작업`을 진행해야 하고, `mappedBy`가 존재하는 필드는 읽기 작업만 수행해야 한다는 것입니다.

<br> <br>

## `양방향 매핑시에는 그냥 양쪽다 값을 넣는 것이 좋다.`

- 객체지향적으로 생각하면 양쪽으로 값을 넣는 것는 것이 좋습니다.

- Entity는 Dto로 Controller에서 반환하기

<br> <br>

## 양방향 매핑시에 무한 루프를 조심하기

- Lombok ToString() 조심

<br> <br>

## `양방향 매핑 정리`

- 단방향 매핑만으로 처음에는 설계를 완료 해야 함(처음부터 양방향 설계는 하면 안됨)

- 양방향 매핑은 반대 방향으로 조회 기능이 추가된 것 뿐

- JPQL에서 역방향으로 탐색할 일이 많음 (그레서 양방향을 써야하는 상황이 존재하긴 함)

- 하지만 단방향 매핑만 잘해놓고, 나중에 필요할 때 양방향 매핑만 일부 추가하면 됨

- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음)

<br> <br>

## `연관관계의 주인을 정하는 기준`

- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨

- `연관관계의 주인은 외래 키의 위치를 기준으로 정해야함`

