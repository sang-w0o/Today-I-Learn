## `경로 표현식`

경로 표현식이라는 것은 쉽게 이야기해서 `.`을 찍어 `객체 그래프를 탐색`하는 것입니다. 

```sql
SELECT m.username    -- 상태 필드
FROM Member m 
JOIN m.team t        -- 단일 값 연관 필드
JOIN m.orders o      -- 컬렉션 값 연관 필드
WHERE t.nmae = '팀A'
```

여기서 m.username, m.team, m.orders, t.name 모두 경로 표현식을 사용한 예입니다.

<br> <br>

## `경로 표현식 용어 정리`

### 상태 필드

- 단순히 값을 저장하기 위한 필드 (ex: m.username)

<br>

### 연관 필드

- 연관관계를 위한 필드
- 단일 값 연관 필드(@ManyToOne, @OneToOne): 대상이 엔티티일 때(ex: m.team)
- 컬렉션 값 연관 필드(@OneToMany, @ManyToMany): 대상이 컬렉션일 때(ex. m.orders)

<br> <br>

## `경로 표현식 특징`

- 상태 필드: 경로 탐색의 끝입니다. 더는 탐색할 수 없습니다.
- 단일 값 연관 경로: `묵시적으로 내부 조인`이 일어납니다. 단일 값 연관 경로는 계속 탐색할 수 있습니다. 
- 컬렉션 값 연관 경로: `묵시적으로 내부 조인`이 일어납니다. 더는 탐색할 수 없습니다.

<br>

결론은 `묵시적 조인`을 웬~만하면 사용하지 않는 것이 좋습니다. (쿼리를 예상하기가 매우 어려움)

<br>

![스크린샷 2021-09-20 오후 9 07 26](https://user-images.githubusercontent.com/45676906/133999476-d60456da-6273-49ec-b0fc-e615fbdf5948.png)

Member와 Team의 연관관계는 `N:1`인데요. 여기서 위와 같이 Member에서 Team을 찾아오는 JPQL을 적으면 어떤 쿼리가 나가게 될까요?

<br>

![스크린샷 2021-09-20 오후 9 09 06](https://user-images.githubusercontent.com/45676906/133999755-cbac564f-325a-4134-ab59-cea2903881c0.png)

객체 입장에서는 Member에서 Team을 조회한 것이지만 DB 입장에서는 Member에서 Team을 조인하려면 내부적으로 `inner join`을 해서 가져와야 한다는 것을 알 수 있습니다. 이것을 `묵시적 내부 조인이 일어난다` 라고 합니다. 즉, 개발을 할 때 조심히 써야 한다는 것을 알 수 있습니다.

<br>

![스크린샷 2021-10-05 오후 2 47 38](https://user-images.githubusercontent.com/45676906/135967407-6b0148a0-d189-42c1-ba2f-f90fb0a143d6.png)

반대로 Team은 List<Member>를 가지고 있는데요. 위의 JPQL처럼 Team에서 member를 참조하는 것은 컬렉션이기 때문에 불가능합니다. 즉, 컬렉션을 참조하기 위해서는 아래와 같이 명시적 JOIN을 사용해야 합니다.

<br>

![스크린샷 2021-10-05 오후 2 49 46](https://user-images.githubusercontent.com/45676906/135967616-36ac1b66-f324-48b1-9145-968361d62c18.png)

위처럼 명시적 JOIN을 통해서 Member의 별칭 m을 얻은 후에 m으로 username을 참조할 수 있습니다. 

<br> <br>

## `경로 표현식 - 예제`

- SELECT o.member.team FROM Order o (가능)
- SELECT t.members FROM Team (가능)
- SELECT t.members.username FROM Team t (불가능)
- SELECT m.username FROM Team t JOIN t.members m (가능)

<br> <br>

## `경로 탐색을 사용한 묵시적 조인 시 주의 사항`

- 항상 `내부 조인`을 사용합니다. 
- 컬렉션은 경로 탐색의 끝입니다. 컬렉션에서 경로 탐색을 하려면 명시적으로 조인해서 별칭을 얻어야 합니다. 
- 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM 절에 영향을 줍니다. 

<br> <br>

## `페치 조인`

페치 조인은 SQL에서 이야기하는 조인의 종류는 아니고 JPQL에서 `성능 최적화`를 위해 제공하는 기능입니다. 연관된 엔티티나 `컬렉션을 SQL 한 번에 조회하는 기능`입니다.

<br> <br>

## `엔티티 페치 조인`

페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회하는 SQL과 JPQL을 보겠습니다. 

```sql
SELECT M.*, T.* 
FROM MEMEBER M
INNER JOIN TEAM T ON M.TEAM_ID = T.ID
```

```sql
SELECT m FROM Member m 
JOIN fetch m.team
```

위의 예제를 보면 JOIN 다음에 `fetch`를 적으면 연관된 엔티티나 컬렉션을 함께 조회할 수 있습니다. 즉, fetch를 적으면 위의 보이는 SQL 처럼 실행되게 됩니다.  

<img width="1240" alt="스크린샷 2021-09-20 오후 9 22 58" src="https://user-images.githubusercontent.com/45676906/134001534-992e11ba-8146-4fc0-952c-aa47ca8e605a.png">

위의 그림을 보면 JOIN과 fetch의 특징을 볼 수 있습니다. 

<br>

![스크린샷 2021-10-05 오후 3 04 54](https://user-images.githubusercontent.com/45676906/135969479-99d8a28a-ac0e-4cd6-83b8-62f1bd100b54.png)

위와 같이 Team A, B를 만들고 Member1(TeamA), Member2(TeamA), Member3(TeamB)에 저장한 후에 Member List를 조회하고 각 멤버들의 이름, 팀 이름을 출력하는 코드를 작성했습니다. 이 때 어떤 쿼리들이 실행되는지 알아보겠습니다. 

<br>

![스크린샷 2021-10-05 오후 3 09 38](https://user-images.githubusercontent.com/45676906/135969758-5b1bc0d4-9460-45b9-aa93-5b81848c0c17.png)

실행되는 커리를 보면 3번의 쿼리가 실행된 것을 볼 수 있습니다. 어떤 실행 과정을 거쳐서 이렇게 실행이 되었을까요? (참고로 Member는 `지연 로딩`으로 설정되어 있습니다.)

```java
List<Member> result = em.createQuery("SELECT m FROM Member m", Member.class)
                    .getResultList();
```

처음에 위의 코드를 통해서 Member를 조회하기 때문에 첫 번째 SELECT 쿼리가 실행된 것을 알 수 있습니다. 이 때 Member는 1차 캐시에도 저장이 되고 영속성 컨텍스트 위에 올라가게 되었을텐데요. 

그리고 두 번째 SELECT 쿼리는 for문 첫 루프에 해당할 때 실행이 될 것입니다. 

```java
for (Member member : result) {
    System.out.println("member = " + member.getUsername() + ", " + member.getTeam().getName());
}
```

가장 첫 for문이 실행될 때 Member가 속한 Team의 이름을 출력하는 코드가 있는데, 위에서 말했듯이 `지연 로딩`을 사용하고 있기 때문에 Team이 사용될 때 Team을 SELECT 해서 가져오는 것을 볼 수 있습니다. 즉, 이 때 TeamA도 1차 캐시에 저장이 될 것입니다. 여기서 1차 캐시에 TeamA가 저장되었기 때문에 두 번째 루프인 Member2는 SELECT 쿼리 없이 1차 캐시에서 조회가 된 것입니다. 

그리고 마지막으로 Member3의 Team은 TeamB인데요. TeamB는 1차 캐시에 없기 때문에 다시 SQL을 통해서 조회가 되어 마지막 SELECT 쿼리가 실행된 것을 볼 수 있습니다. 이렇게 해서 총 3번의 SELECT 쿼리가 실행되었습니다. 현재는 Member 3명에 2명이 같은 팀이기 때문에 3번의 쿼리만 실행되었는데 Member 100명이 모두 다른 팀이라면 101번의 쿼리가 실행될 것인데요. `서비스가 커지면 커질 수록 상당히 문제가 많은 상태가 될 것입니다.`

<br> <br>

## `컬렉션 페치 조인`

이러한 문제를 해결할 때 `fetch join`을 사용하면 되는데요. 어떻게 해결할 수 있는지 알아보겠습니다. 

![스크린샷 2021-10-05 오후 3 19 45](https://user-images.githubusercontent.com/45676906/135970858-990c5987-2d44-4ca2-b581-c9fa7b768a20.png)

위와 같이 `fetch join`을 통해서 Member-Team을 조인하면 아래와 같은 쿼리가 실행됩니다.

<br>

![스크린샷 2021-10-05 오후 3 20 00](https://user-images.githubusercontent.com/45676906/135970952-71d97c78-914c-4509-8a33-4ce2c9ca8ecc.png)

fetch join을 사용하니 Member와 Team을 JOIN 해서 한번에 가져오게 되고 쿼리도 1번만 실행된 것을 볼 수 있습니다. 즉, Team도 처음에 가져올 때부터 1차 캐시에 올라가기 때문에 지연로딩을 하더라도 Team이 Proxy 객체가 아니라 진짜 객체를 사용하게 됩니다. 

<br> <br>

## `컬렉션 페치 조인`

일대다 관계인 컬렉션을 페치조인하는 경우를 말합니다. 

```sql
-- JPQL
SELECT t
FROM Team t JOIN FETCH t.members
WHERE t.name = '팀A'
```

```sql
SELECT T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID = M.TEAM_ID
WHERE T.NAME = '팀A'
```

위와 같이 Team은 List<Member>를 가지고 있는데 이렇게 Team에서 Member로 가는 참조의 경우를 말합니다.  

<br>

![스크린샷 2021-10-05 오후 3 31 48](https://user-images.githubusercontent.com/45676906/135971974-1fe3b225-a01d-4a7b-8a12-4a6c2799f098.png)

그래서 이번에 Team에서 Member로 fetch join을 한 후에 어떻게 실행되는지 보겠습니다. 

<br>

![스크린샷 2021-10-05 오후 3 33 21](https://user-images.githubusercontent.com/45676906/135972145-f9bda6f0-2044-462a-b5fe-8e77e5ad6a51.png)

마지막 결과를 보면 TeamA에 속한 Member가 2명이다 보니 중복되어서 2번 출력되는 것을 볼 수 있는데요. 이 부분을 컬렉션에서 조심해야 합니다. 

<br>

<img width="563" alt="스크린샷 2021-10-05 오후 3 34 47" src="https://user-images.githubusercontent.com/45676906/135972254-05eff7c2-e075-478e-8c29-11dd1945ae37.png">

일다다 조인이기 때문에 TeamA에 2명의 멤버가 존재하기 때문에 위의 그림에서 볼 수 있듯이 결과가 2개가 나오게 될 수 밖에 없습니다. 

<br> <br>

## `페치 조인과 DISTINCT`

SQL의 DISTINCT는 중복된 결과를 제거하는 명령어입니다. JPQL의 DISTINCT 명령어는 SQL에 DISTINCT를 추가하는 것은 물론이고 애플리케이션에서 한 번 더 중복을 제거합니다. 

![스크린샷 2021-10-05 오후 3 42 04](https://user-images.githubusercontent.com/45676906/135973112-cb2d156d-8d4d-44e7-b610-6cb06927ade5.png)

위와 같이 `distinct`를 사용하면 되는데요. JPQL에서의 DISTINCT는 위에서 말했듯이 애플리케이션에서 한번 더 중복을 제거해줍니다. 

<br>

<img width="554" alt="스크린샷 2021-10-05 오후 3 43 43" src="https://user-images.githubusercontent.com/45676906/135973290-8531d144-5e12-448c-a3fd-6a9e7dc7c2bf.png">

즉, 위와 같이 Team의 중복된 엔티티도 제거해주는 특징이 있습니다. 그래서 DISTINCT를 적용하고 결과를 보면 아래와 같습니다. 

<br>

![스크린샷 2021-10-05 오후 3 44 32](https://user-images.githubusercontent.com/45676906/135973416-417f3587-4c24-4d11-8947-02e52266d078.png)

이번에는 중복이 제거되어서 결과가 2개만 나온 것을 볼 수 있습니다. 

<br> <br>

## `페치 조인과 일반 조인의 차이`

- JPQL은 결과를 반환할 때 연관관계를 고려하지 않습니다.
- 단지 SELECT 절에 지정한 엔티티만 조회할 뿐입니다.
- 여기서는 팀 엔티티만 조회하고, 회원 엔티티는 조회하지 않습니다.
- `페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시 로딩)`
- `페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념`

<br>

일반 조인 실행시 연관된 엔티티를 함께 조회하지 않습니다. 한번 일반 JOIN으로 실행된 쿼리는 어떻게 출력되는지 알아보겠습니다. 

![스크린샷 2021-10-05 오후 3 51 30](https://user-images.githubusercontent.com/45676906/135974198-d714f730-41cb-47a2-83bf-5541704d1deb.png)

<br>

![스크린샷 2021-10-05 오후 3 51 00](https://user-images.githubusercontent.com/45676906/135974149-b6bac8fb-b68f-4c17-a9ae-73c04748bf53.png)

그러면 INNER JOIN으로 가져오는 것은 똑같지만 가져오는 컬럼을 보면 t만 적었기 때문에 Team에 관련된 것들만 가져오는 것을 볼 수 있습니다. 그리고 Member에 대한 데이터도 로딩이 되지 않았기 때문에 Member를 조회할 때 여러 번의 쿼리가 실행되는 것도 볼 수 있습니다.

<br>

![스크린샷 2021-10-05 오후 3 53 39](https://user-images.githubusercontent.com/45676906/135974454-f92379cf-00a2-41b1-b2b1-25d419427473.png)

<br> <br>

## `페치 조인의 특징과 한계`

- 페치 조인 대상에는 별칭을 줄 수 없습니다.

fetch join 자체가 연관된 데이터를 다 가져오는 것이기 때문에 별칭을 잘못 사용했을 때 연관된 데이터 수가 달라져서 데이터 무결성이 깨질 수 있으므로 조심해서 사용해야 합니다. 

<br> 

- 둘 이상의 컬렉션을 페치할 수 없습니다. 

만약에 Team이 List<Member>도 가질 수 있고, List<Order>도 가질 수 있는 경우를 말합니다. 이럴 때 fetch join을 사용하면 1 x N x M 이 되므로 사용하는 것을 주의해야 합니다. 

<br>

- 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없습니다.

일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징이 가능합니다.(데이터가 늘어나지 않기 때문에) 반면에 일대다 같은 경우는 조인했을 때 데이터가 늘어나기 때문에 페이징을 할 수 없습니다. 

![스크린샷 2021-10-06 오후 12 37 23](https://user-images.githubusercontent.com/45676906/136136867-56aa1247-b50b-4f79-a824-159405ff91fa.png)

<br>

![스크린샷 2021-10-06 오후 12 37 50](https://user-images.githubusercontent.com/45676906/136136917-7bb38d73-7138-440f-a76b-cdb5dc9c0f0a.png)

일대다 관계에서 페이징을 사용한 후에 실행하면 위와 같이 `applying in memory`라고 경고가 뜨는 것을 볼 수 있습니다. 즉, 모든 연관된 데이터들을 메모리에 올리고 페이징 하는 것이기 때문에 데이터가 엄청나게 많다면 위험한 상황이 될 수 있습니다.

<br>

![스크린샷 2021-10-06 오후 12 40 29](https://user-images.githubusercontent.com/45676906/136137131-ac62c375-dac1-41d0-a554-54fb6386d13e.png)

이러한 상황에서 페이징을 하기 위해서는 반대로 `Member -> Team`으로 `다대일` 관계로 `fetch join`을 하는 방법이 있습니다. 

<br> 

페치조인에서 페이징을 하는 또 다른 방법에 대해서도 정리해보겠습니다. 

![스크린샷 2021-10-06 오후 1 00 30](https://user-images.githubusercontent.com/45676906/136138759-7aceec25-9ecf-4f33-94e5-2a97ef8cba4f.png)

위와 같이 현재 `지연 로딩`으로 설정 되어 있고, Team을 페이징 쿼리를 통해서 가져오고 있습니다. 

<br>

![스크린샷 2021-10-06 오후 1 04 56](https://user-images.githubusercontent.com/45676906/136139084-18076fc0-72fc-4096-ab39-acacb7495db9.png)

실행되는 쿼리를 보면 위와 같은데요. 첫 번째 쿼리는 Team을 가져올 때 실행되는 쿼리이고, 두, 세 번째 쿼리는 지연로딩이기 때문에 for문을 돌면서 Member에 접근할 때 실행되는 쿼리입니다. 즉, N + 1 쿼리가 실행되고 있는 것을 볼 수 있습니다. 여기까지는 계속 살펴보았던 내용인데요. 여기서 `문제가 컬렉션의 페치조인에서는 페이징 쿼리를 사용할 수 없다.` 였는데요.  이러한 문제를 아래와 같이 해결할 수도 있습니다. 

<br>

![스크린샷 2021-10-06 오후 1 09 32](https://user-images.githubusercontent.com/45676906/136139387-18164ac5-d938-4b06-a751-a1c5151ad902.png)

Team에서 `@BatchSize(size = 100)`으로 설정하는 방법인데요.(사이즈는 1000 이하의 적당한 값을 주기) 설정한 후에 실행하면 어떤 쿼리들이 실행되는지 알아보겠습니다. 

![스크린샷 2021-10-06 오후 1 11 32](https://user-images.githubusercontent.com/45676906/136139648-03394ebb-935a-4c48-95da-a41dcbd283af.png)

이번에는 Batch size로 준 값만큼 IN 쿼리를 사용해서 한번에 같이 가져오는 것을 볼 수 있습니다. 이렇게 페치조인 컬렉션 관계에서 페이징 쿼리의 N + 1 문제를 해결할 수 있습니다. 

<br>

![스크린샷 2021-10-06 오후 1 15 45](https://user-images.githubusercontent.com/45676906/136139828-8e9a4313-1115-4c95-ab77-1b509a4c2bf8.png)

글로벌적으로 설정하는 방법은 `persistence.xml`에서 위와 같이 `default-batch-size` 값을 지정하면 똑같은 결과를 얻을 수 있습니다. 


<br> <br> 

## `페치 조인 정리`

- 연관된 엔티티들을 SQL 한번으로 조회합니다. (성능 최적화)
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선합니다.(@OneToMany(fetch=FetchType.LAZY))
- 실무에서 글로벌 로딩 전략은 모두 지연 로딩을 지향합니다. 
- 최적화가 필요한 곳은 페치조인을 적용하면서 해결해나갑니다.
- 모든 것을 페치 조인으로 해결할 수는 없습니다. 
- 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적입니다.

<br> <br>

## `엔티티 직접 사용 - 기본 키 값`

```jpaql
SELECT COUNT(m.id) FROM Member m // 엔티티의 아이디를 사용
SELECT COUNT(m) FROM Member m    // 엔티티를 직접 사용
```

JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키 값을 사용합니다.

<br>

### `엔티티를 파라미터로 전달`

```java
String jpql = "SELECT m FROM Member m WHERE m = :member";
List resultList = em.createQuery(jpql)
                    .setParameter("member", member)
                    .getResultList();
```

<br>

### `식별자를 직접 전달`

```java
String jpql = "SELECT m FROM Meber m WHERE m.id = :memberId";
List resultList = em.createQuery(jpql)
                    .setParameter("memberId", memberId)
                    .getResultList()
```

<br>

### `실행된 SQL`

```sql
SELECT m.* FROM Member m WHERE m.id = ?
```

엔티티 자체로 조회하더라도 식별자 값으로 조회하는 것처럼 동작하게 됩니다.

<br> <br>

## `Named 쿼리`

JPQL 쿼리는 크게 `동적 쿼리`와 `정적 쿼리`로 나눌 수 있습니다. 

- 동적 쿼리 : em.createQuery("SELECT ...) 처럼 JPQL을 문자로 완성해서 직접 넘기는 것을 동적 쿼리라고 합니다. 
- 정적 쿼리 : 미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용할 수 있는데 이것을 `Named 쿼리` 라고 합니다. 

<br>

`Named 쿼리는 애플리케이션 로딩 시점에 JPQL 문법을 체크하고 미리 파싱해둡니다.` 따라서 오류를 빨리 확인할 수 있고, 사용하는 시점에는 파싱된 결과를 재사용하므로 성능상 이점도 있습니다. 

![스크린샷 2021-10-06 오후 2 20 55](https://user-images.githubusercontent.com/45676906/136144919-29deedc3-d4c7-4d20-9380-762b6011e48d.png)

<br>

![스크린샷 2021-10-06 오후 2 38 37](https://user-images.githubusercontent.com/45676906/136146356-28d2f295-988f-489a-bdab-7fc5ca53f24d.png)

<br> <br>

## `JPQL 벌크 연산`

### `벌크 연산`

- 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?

<br>

JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL을 실행해야 합니다. 즉, 변경된 데이터가 100건이라면 100번의 UPDATE SQL을 실행해야 합니다. 

<br> <br>

## `벌크 연산 예제`

쿼리 한 번으로 여러 테이블 로구 변경하는 것을 말합니다. 

![스크린샷 2021-10-06 오후 2 45 56](https://user-images.githubusercontent.com/45676906/136147147-a4ed98fd-d895-4b85-9928-e6a111acc7d0.png)

