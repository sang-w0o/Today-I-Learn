## `경로 표현식`

경로 표현힉이라는 것은 쉽게 이야기해서 `.`을 찍어 객체 그래프를 탐색하는 것입니다. 

```sql
SELECT m.username    -- 상태 필드
FROM Member m 
JOIN m.team t        -- 단일 값 연관 필드
JOIN m.orders o      -- 컬렉션 값 연관 필드
WHERE t.nmae = '팀A'
```

여기서 m.username, m.team, m.orders, t.name 모두 경로 표현식을 사용한 예입니다.

<br> <br>

## `경로 표현식 용어 정리`

### 상태 필드

- 단순히 값을 저장하기 위한 필드 (ex: m.username)

<br>

### 연관 필드

- 연관관계를 위한 필드
- 단일 값 연관 필드(@ManyToOne, @OneToOne): 대상이 엔티티일 때(ex: m.team)
- 컬렉션 값 연관 필드(@OneToMany, @ManyToMany): 대상이 컬렉션일 때(ex. m.orders)

<br> <br>

## `경로 표현식 특징`

- 상태 필드: 경로 탐색의 끝입니다. 더는 탐색할 수 없습니다.
- 단일 값 연관 경로: `묵시적으로 내부 조인`이 일어납니다. 단일 값 연관 경로는 계속 탐색할 수 있습니다. 
- 컬렉션 값 연관 경로: `묵시적으로 내부 조인`이 일어납니다. 더는 탐색할 수 없습니다.

<br>

결론은 `묵시적 조인`을 웬~만하면 사용하지 않는 것이 좋습니다. (쿼리를 예상하기가 매우 어려움)

<br>

![스크린샷 2021-09-20 오후 9 07 26](https://user-images.githubusercontent.com/45676906/133999476-d60456da-6273-49ec-b0fc-e615fbdf5948.png)

Member와 Team의 연관관계는 `N:1`인데요. 여기서 위와 같이 Member에서 Team을 찾아오는 JPQL을 적으면 어떤 쿼리가 나가게 될까요?

<br>

![스크린샷 2021-09-20 오후 9 09 06](https://user-images.githubusercontent.com/45676906/133999755-cbac564f-325a-4134-ab59-cea2903881c0.png)

객체 입장에서는 Member에서 Team을 조회한 것이지만 DB 입장에서는 Member에서 Team을 조인하려면 내부적으로 `inner join`을 해서 가져와야 한다는 것을 알 수 있습니다. 이것을 `묵시적 내부 조인이 일어난다` 라고 합니다. 즉, 개발을 할 때 조심히 써야 한다는 것을 알 수 있습니다.

<br>

![스크린샷 2021-10-05 오후 2 47 38](https://user-images.githubusercontent.com/45676906/135967407-6b0148a0-d189-42c1-ba2f-f90fb0a143d6.png)

반대로 Team은 List<Member>를 가지고 있는데요. 위의 JPQL처럼 Team에서 member를 참조하는 것은 컬렉션이기 때문에 불가능합니다. 즉, 참조하기 위해서는 아래와 같이 명시적 JOIN을 사용해야 합니다.

<br>

![스크린샷 2021-10-05 오후 2 49 46](https://user-images.githubusercontent.com/45676906/135967616-36ac1b66-f324-48b1-9145-968361d62c18.png)

위처럼 명시적 JOIN을 통해서 Member의 별칭 m을 얻은 후에 m으로 username을 참조할 수 있습니다. 

<br> <br>

## `경로 표현식 - 예제`

- SELECT o.member.team FROM Order o (가능)
- SELECT t.members FROM Team (가능)
- SELECT t.members.username FROM Team t (불가능)
- SELECT m.username FROM Team t JOIN t.members m (가능)

<br> <br>

## `경로 탐색을 사용한 묵시적 조인 시 주의 사항`

- 항상 내부 조인을 사용합니다. 
- 컬렉션은 경로 탐색의 끝입니다. 컬렉션에서 경로 탐색을 하려면 명시적으로 조인해서 별칭을 얻어야 합니다. 
- 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM 절에 영향을 줍니다. 

<br> <br>

## `페치 조인`

페치 조인은 SQL에서 이야기하는 조인의 종류는 아니고 JPQL에서 `성능 최적화`를 위해 제공하는 기능입니다. 연관된 엔티티나 `컬렉션을 SQL 한 번에 조회하는 기능`입니다.

<br> <br>

## `엔티티 페치 조인`

페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회하는 SQL과 JPQL을 보겠습니다. 

```sql
SELECT M.*, T.* 
FROM MEMEBER M
INNER JOIN TEAM T ON M.TEAM_ID = T.ID
```

```sql
SELECT m FROM Member m 
JOIN fetch m.team
```

위의 예제를 보면 JOIN 다음에 `fetch`를 적으면 연관된 엔티티나 컬렉션을 함께 조회할 수 있습니다. 즉, fetch를 적으면 위의 보이는 SQL 처럼 실행되게 됩니다.  

<img width="1240" alt="스크린샷 2021-09-20 오후 9 22 58" src="https://user-images.githubusercontent.com/45676906/134001534-992e11ba-8146-4fc0-952c-aa47ca8e605a.png">

위의 그림을 보면 JOIN과 fetch의 특징을 볼 수 있습니다. 

<br>

![스크린샷 2021-10-05 오후 3 04 54](https://user-images.githubusercontent.com/45676906/135969479-99d8a28a-ac0e-4cd6-83b8-62f1bd100b54.png)

위와 같이 Team A, B를 만들고 Member1(TeamA), Member2(TeamA), Member3(TeamB)에 저장한 후에 Member List를 조회하고 각 멤버들의 이름, 팀 이름을 출력하는 코드를 작성했습니다. 이 때 어떤 쿼리들이 실행되는지 알아보겠습니다. 

<br>

![스크린샷 2021-10-05 오후 3 09 38](https://user-images.githubusercontent.com/45676906/135969758-5b1bc0d4-9460-45b9-aa93-5b81848c0c17.png)

실행되는 커리를 보면 3번의 쿼리가 실행된 것을 볼 수 있습니다. 어떤 실행 과정을 거쳐서 이렇게 실행이 되었을까요? (참고로 Member는 `지연 로딩`으로 설정되어 있습니다.)

```java
List<Member> result = em.createQuery("SELECT m FROM Member m", Member.class)
                    .getResultList();
```

처음에 위의 코드를 통해서 Member를 조회하기 때문에 첫 번째 SELECT 쿼리가 실행된 것을 알 수 있습니다. 이 때 Member는 1차 캐시에도 저장이 되고 영속성 컨텍스트 위에 올라가게 되었을텐데요. 

두 번째 SELECT 쿼리는 for문 첫 루프에 해당할 때 실행이 될 것입니다. 

```java
for (Member member : result) {
    System.out.println("member = " + member.getUsername() + ", " + member.getTeam().getName());
}
```

가장 첫 for문이 실행될 때 Member가 속한 Team의 이름을 출력하는 코드가 있는데, 위에서 말했듯이 `지연 로딩`을 사용하고 있기 때문에 Team이 사용될 때 Team을 SELECT 해서 가져오는 것을 볼 수 있습니다. 즉, 이 때 TeamA도 1차 캐시에 저장이 될 것입니다. 여기서 1차 캐시에 TeamA가 저장되었기 때문에 두 번째 루프인 Member2는 SELECT 쿼리 없이 1차 캐시에서 조회가 된 것입니다. 

그리고 마지막으로 Member3의 Team은 TeamB인데요. TeamB는 1차 캐시에 없기 때문에 다시 SQL을 통해서 조회가 되어 마지막 SELECT 쿼리가 실행된 것을 볼 수 있습니다. 이렇게 해서 총 3번의 SELECT 쿼리가 실행되었습니다. 현재는 Member 3명에 2명이 같은 팀이기 때문에 3번의 쿼리만 실행되었는데 Member 100명이 모두 다른 팀이라면 101번의 쿼리가 실행될 것인데요. `서비스가 커지면 커질 수록 상당히 문제가 많은 상태가 될 것입니다.`

<br> <br>

## `컬렉션 페치 조인`

이러한 문제를 해결할 때 `fetch join`을 사용하면 되는데요. 어떻게 사용해서 해결할 수 있는지 알아보겠습니다. 

![스크린샷 2021-10-05 오후 3 19 45](https://user-images.githubusercontent.com/45676906/135970858-990c5987-2d44-4ca2-b581-c9fa7b768a20.png)

위와 같이 `fetch join`을 통해서 Member-Team을 조인하면 아래와 같은 쿼리가 실행됩니다. 

<br>

![스크린샷 2021-10-05 오후 3 20 00](https://user-images.githubusercontent.com/45676906/135970952-71d97c78-914c-4509-8a33-4ce2c9ca8ecc.png)

Member와 Team을 JOIN 해서 한번에 가져오게 되고 쿼리도 1번만 실행된 것을 볼 수 있습니다. 즉, Team도 처음에 가져올 때부터 1차 캐시에 올라가기 때문에 지연로딩을 하더라도 Team이 Proxy 객체가 아니라 진짜 객체를 사용하게 됩니다. 

<br> <br>

## `컬렉션 페치 조인`

일대다 관계인 컬렉션을 페치조인하는 경우를 말합니다. 

```sql
-- JPQL
SELECT t
FROM Team t JOIN FETCH t.members
WHERE t.name = '팀A'
```

```sql
SELECT T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID = M.TEAM_ID
WHERE T.NAME = '팀A'
```

위와 같이 Team은 List<Member>를 가지고 있는데 이렇게 Team에서 Member로 가는 참조의 경우를 말합니다.  

<br>

![스크린샷 2021-10-05 오후 3 31 48](https://user-images.githubusercontent.com/45676906/135971974-1fe3b225-a01d-4a7b-8a12-4a6c2799f098.png)

그래서 이번에 Team에서 Member로 fetch join을 한 후에 어떻게 실행되는지 보겠습니다. 

![스크린샷 2021-10-05 오후 3 33 21](https://user-images.githubusercontent.com/45676906/135972145-f9bda6f0-2044-462a-b5fe-8e77e5ad6a51.png)

마지막 결과를 보면 TeamA에 속한 Member가 2명이다 보니 중복되어서 2번 출력되는 것을 볼 수 있는데요. 이 부분을 컬렉션에서 조심해야 합니다. 

<br>

<img width="563" alt="스크린샷 2021-10-05 오후 3 34 47" src="https://user-images.githubusercontent.com/45676906/135972254-05eff7c2-e075-478e-8c29-11dd1945ae37.png">

일다다 조인이기 때문에 TeamA에 2명의 멤버가 존재하기 때문에 위의 그림에서 볼 수 있듯이 결과가 2개가 나오게 될 수 밖에 없습니다. 

<br> <br>

## `페치 조인과 DISTINCT`

SQL의 DISTINCT는 중복된 결과를 제거하는 명령어입니다. JPQL의 DISTINCT 명령어는 SQL에 DISTINCT를 추가하는 것은 물론이고 애플리케이션에서 한 번 더 중복을 제거합니다. 

![스크린샷 2021-10-05 오후 3 42 04](https://user-images.githubusercontent.com/45676906/135973112-cb2d156d-8d4d-44e7-b610-6cb06927ade5.png)

위와 같이 `distinct`를 사용하면 되는데요. JPQL에서의 DISTINCT는 위에서 말했듯이 애플리케이션에서 한번 더 중복을 제거해줍니다. 

<br>

<img width="554" alt="스크린샷 2021-10-05 오후 3 43 43" src="https://user-images.githubusercontent.com/45676906/135973290-8531d144-5e12-448c-a3fd-6a9e7dc7c2bf.png">

즉, 위와 같이 Team의 중복된 엔티티도 제거해주는 특징이 있습니다. 그래서 DISTINCT를 적용하고 결과를 보면 아래와 같습니다. 

<br>

![스크린샷 2021-10-05 오후 3 44 32](https://user-images.githubusercontent.com/45676906/135973416-417f3587-4c24-4d11-8947-02e52266d078.png)

이번에는 중복이 제거되어서 결과가 2개만 나온 것을 볼 수 있습니다. 

<br> <br>

## `페치 조인과 일반 조인의 차이`

- JPQL은 결과를 반환할 때 연관관계를 고려하지 않습니다.
- 단지 SELECT 절에 지정한 엔티티만 조회할 뿐입니다.
- 여기서는 팀 엔티티만 조회하고, 회원 엔티티는 조회하지 않습니다.
- `페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시 로딩)`
- `페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념`

<br>

일반 조인 실행시 연관된 엔티티를 함께 조회하지 않습니다. 한번 일반 JOIN으로 실행된 쿼리는 어떻게 출력되는지 알아보겠습니다. 

![스크린샷 2021-10-05 오후 3 51 30](https://user-images.githubusercontent.com/45676906/135974198-d714f730-41cb-47a2-83bf-5541704d1deb.png)

<br>

![스크린샷 2021-10-05 오후 3 51 00](https://user-images.githubusercontent.com/45676906/135974149-b6bac8fb-b68f-4c17-a9ae-73c04748bf53.png)

그러면 INNER JOIN으로 가져오는 것은 똑같지만 가져오는 컬럼을 보면 t만 적었기 때문에 Team에 관련된 것들만 가져오는 것을 볼 수 있습니다. 그리고 Member에 대한 데이터도 로딩이 되지 않았기 때문에 Member를 조회할 때 여러 번의 쿼리가 실행되는 것도 볼 수 있습니다.

<br>

![스크린샷 2021-10-05 오후 3 53 39](https://user-images.githubusercontent.com/45676906/135974454-f92379cf-00a2-41b1-b2b1-25d419427473.png)


