# `JPQL 소개`

JPQL은 `엔티티 객체를 조회하는 객체지향 쿼리이고, 문법은 SQL과 비슷합니다. JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않습니다.` 그리고 데이터베이스 방언만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있습니다. 

![스크린샷 2021-09-03 오전 5 46 14](https://user-images.githubusercontent.com/45676906/131913834-86972d00-7c3d-48fb-8a94-843b9b26af71.png)

가령, 코드로 보면 위와 같이 `JPQL`을 사용할 수 있습니다. JPQL 코드를 보면 Member는 테이블이 아니라 엔티티를 대상으로 쿼리를 작성한 것입니다. 즉, 위의 코드를 실행하면 아래와 같은 쿼리가 만들어집니다.

<br>

![스크린샷 2021-09-03 오전 5 47 46](https://user-images.githubusercontent.com/45676906/131913989-be6f9bf2-2856-4b1e-81e1-c438482e0706.png)

<br> <br>

## `Criteria 소개`

위의 JPQL 코드를 보면 단순한 String 이라는 것을 알 수 있습니다. 이렇게 단순한 String 이라면 `동적 쿼리를 만들기가 매우 어렵다`라는 단점을 가지고 있는데요. 동적쿼리를 JPQL로 사용한다면 단순히 문자열로 된 JPQL 쿼리들을 +로 연결해서 해야 하는데, 이러면 버그가 날 확률도 높고 관리하기가 상당히 쉽지 않습니다.

그래서 대안으로 나온 것이 `Criteria` 입니다. 

![스크린샷 2021-09-03 오전 5 54 34](https://user-images.githubusercontent.com/45676906/131914825-5e87f23c-2d73-4823-8392-1f167d14b4a1.png)

사용법은 위와 같이 할 수 있습니다. 이것은 쿼리를 문자열로 작성하는 것이 아니라 메소드로 작성하여 좀 더 편할 순 있지만 여전히 어렵고 까다롭다고 느껴집니다. 또한 가독성도 좋지 않다고 생각합니다.

<br> <br>

## `QueryDSL 소개`

```java
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

// 쿼리, 결과조회
List<Member> members =
    query.from(member)
        .where(member.username.eq("kim"))
        .list(member);
```

위의 코드는 QueryDSL로 작성한 코드입니다. 훨씬 가독성도 좋고 사용성도 편리하고 좋다는 것을 느낄 수 있습니다. 자바 코드로 JPQL을 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있다는 장점이 있습니다.  

<br> <br>

## `네이티브 SQL 소개`

JPA는 SQL을 직접 사용할 수 있는 기능을 지원하는데 이것을 `네이티브 SQL`이라 합니다. JPQL을 사용해도 가끔은 특정 데이터베이스에 의존하는 기능을 사용해야 할 때가 있습니다.

![스크린샷 2021-09-03 오전 6 05 10](https://user-images.githubusercontent.com/45676906/131916067-65b1a0c8-83d9-4dc2-b57a-561e89ea5504.png)

<br> <br>

## `JPQL이란?`

- JPQL은 객체지향 쿼리 언어입니다. 따라서 테이블을 대상으로 쿼리 하는 것이 아니라 `엔티티 객체를 대상으로 쿼리`합니다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않습니다.
- JPQL은 결국 SQL로 변환됩니다.

<br>

<img width="709" alt="스크린샷 2021-09-03 오전 6 08 32" src="https://user-images.githubusercontent.com/45676906/131916450-7d8bc5ed-a842-4d06-92f1-eefb441d7ac2.png">

위의 모델을 가지고 예제 코드를 보면서 진행해보겠습니다. 그 전에 먼저 JPQL 문법 특정이 대해서 알아보겠습니다. 

<br> <br>

## `JPQL 문법`

- `select m from Member as m where m.age > 18` 엔티티와 속성은 대소문자를 구분합니다.(Member, age)
- JPQL 키워드는 대소문자 구분하지 않습니다.(SELECT, FROM, where)
- 엔티티 이름 사용, 테이블 이름이 아닙니다.
- `별칠은 필수입니다.`

<br> <br>

## `TypeQuery, Query`

- TypeQuery: 반환 타입이 명확할 때 사용합니다.
- Query: 반환 타입이 명확하지 않을 때 사용합니다.

<br>

![스크린샷 2021-09-03 오전 6 22 36](https://user-images.githubusercontent.com/45676906/131918011-fb02df07-843f-4965-a423-85ea0919b629.png)

위의 코드를 보면 type1은 Member 전체를 가져오기 때문에 Member 타입으로 TypeQuery를 사용할 수 있고, type2는 username만 가져오기 때문에 String 타입으로 type2를 가져올 수 있습니다. type3는 username은 String이고 age는 int 이기 때문에 타입을 정할 수 없습니다. 그래서 이럴 때는 `Query`를 사용합니다.

<br> <br>

## `결과 조회`

![스크린샷 2021-09-03 오전 6 25 40](https://user-images.githubusercontent.com/45676906/131918340-a49d54b8-9e02-4b35-91f8-ac7e9e9d5554.png)

위와 같이 `getResultList()`를 사용하면 바로 `List<타입>` 형태로 가져올 수 있습니다.

<br>

![스크린샷 2021-09-03 오전 6 27 24](https://user-images.githubusercontent.com/45676906/131918535-566d32ed-01f0-4b32-b989-6155f14fa137.png)

그리고 `getSingleResult()`라는 메소드도 존재하는데 이것은 정확히 하나만 가져올 때 사용합니다. 이 메소드에는 주의할 점이 있습니다.

- `getSingleResult()`로 조회했을 때 `결과가 정확히 하나`여야 하는데, 결과가 없다면 `javax.persistence.NoResultException` 에러가 발생합니다.
- 둘 이상이면 `javax.persistence.NonUniqueResultException` 에러가 발생합니다.

<br> <br>

## `파라미터 바인딩`

바인딩은 `이름 기준`, `위치 기준`이 존재합니다.

<br>

### 이름 기준

![스크린샷 2021-09-03 오전 6 32 49](https://user-images.githubusercontent.com/45676906/131919134-e488fd78-421d-4c7e-a824-d99cbfefbd21.png)

<br>

![스크린샷 2021-09-03 오전 6 33 30](https://user-images.githubusercontent.com/45676906/131919188-fb80de36-f442-4c27-8629-0394b194a2a9.png)

위와 같이 username으로 제대로 바인딩이 잘 된 것을 볼 수 있습니다.

<br>

### 위치 기준

하나 추가되면 다 바꿔야 하기 때문에 위치 기준은 웬만하면 사용하지 않는 것이 좋습니다. 사용법은 `?1`을 사용하면 됩니다.

![스크린샷 2021-09-03 오전 6 35 48](https://user-images.githubusercontent.com/45676906/131919447-7a773a93-7102-4bc5-b116-63c5c04054fe.png)

<br> <br>

## `프로젝션`

SELECT 절에 조회할 대상을 지정하는 것을 `프로젝션`이라 하고, [SELECT {프로젝션 대상} FROM] 으로 대상을 선택합니다.

- SELECT m FROM Member m -> 엔티티 프로젝션
- SELECT m.team FROM Member m -> 엔티티 프로젝션
- SELECT m.address FROM Member m -> 임베디드 프로젝션 (Address는 Embedded 타입이어서)

<br>

