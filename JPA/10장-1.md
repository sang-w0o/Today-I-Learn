# `JPQL 소개`

JPQL은 `엔티티 객체를 조회하는 객체지향 쿼리이고, 문법은 SQL과 비슷합니다. JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않습니다.` 그리고 데이터베이스 방언만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있습니다. 

![스크린샷 2021-09-03 오전 5 46 14](https://user-images.githubusercontent.com/45676906/131913834-86972d00-7c3d-48fb-8a94-843b9b26af71.png)

가령, 코드로 보면 위와 같이 `JPQL`을 사용할 수 있습니다. JPQL 코드를 보면 Member는 테이블이 아니라 엔티티를 대상으로 쿼리를 작성한 것입니다. 즉, 위의 코드를 실행하면 아래와 같은 쿼리가 만들어집니다.

<br>

![스크린샷 2021-09-03 오전 5 47 46](https://user-images.githubusercontent.com/45676906/131913989-be6f9bf2-2856-4b1e-81e1-c438482e0706.png)

<br> <br>

## `Criteria 소개`

위의 JPQL 코드를 보면 단순한 String 이라는 것을 알 수 있습니다. 이렇게 단순한 String 이라면 `동적 쿼리를 만들기가 매우 어렵다`라는 단점을 가지고 있는데요. 동적쿼리를 JPQL로 사용한다면 단순히 문자열로 된 JPQL 쿼리들을 +로 연결해서 해야 하는데, 이러면 버그가 날 확률도 높고 관리하기가 상당히 쉽지 않습니다.

그래서 대안으로 나온 것이 `Criteria` 입니다. 

![스크린샷 2021-09-03 오전 5 54 34](https://user-images.githubusercontent.com/45676906/131914825-5e87f23c-2d73-4823-8392-1f167d14b4a1.png)

사용법은 위와 같이 할 수 있습니다. 이것은 쿼리를 문자열로 작성하는 것이 아니라 메소드로 작성하여 좀 더 편할 순 있지만 여전히 어렵고 까다롭다고 느껴집니다. 또한 가독성도 좋지 않다고 생각합니다.

<br> <br>

## `QueryDSL 소개`

```java
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

// 쿼리, 결과조회
List<Member> members =
    query.from(member)
        .where(member.username.eq("kim"))
        .list(member);
```

위의 코드는 QueryDSL로 작성한 코드입니다. 훨씬 가독성도 좋고 사용성도 편리하고 좋다는 것을 느낄 수 있습니다. 자바 코드로 JPQL을 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있다는 장점이 있습니다.  

<br> <br>

## `네이티브 SQL 소개`

JPA는 SQL을 직접 사용할 수 있는 기능을 지원하는데 이것을 `네이티브 SQL`이라 합니다. JPQL을 사용해도 가끔은 특정 데이터베이스에 의존하는 기능을 사용해야 할 때가 있습니다.

![스크린샷 2021-09-03 오전 6 05 10](https://user-images.githubusercontent.com/45676906/131916067-65b1a0c8-83d9-4dc2-b57a-561e89ea5504.png)

<br> <br>

## `JPQL이란?`

- JPQL은 객체지향 쿼리 언어입니다. 따라서 테이블을 대상으로 쿼리 하는 것이 아니라 `엔티티 객체를 대상으로 쿼리`합니다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않습니다.
- JPQL은 결국 SQL로 변환됩니다.

<br>

<img width="709" alt="스크린샷 2021-09-03 오전 6 08 32" src="https://user-images.githubusercontent.com/45676906/131916450-7d8bc5ed-a842-4d06-92f1-eefb441d7ac2.png">

위의 모델을 가지고 예제 코드를 보면서 진행해보겠습니다. 그 전에 먼저 JPQL 문법 특정이 대해서 알아보겠습니다. 

<br> <br>

## `JPQL 문법`

- `select m from Member as m where m.age > 18` 엔티티와 속성은 대소문자를 구분합니다.(Member, age)
- JPQL 키워드는 대소문자 구분하지 않습니다.(SELECT, FROM, where)
- 엔티티 이름 사용, 테이블 이름이 아닙니다.
- `별칠은 필수입니다.`

<br> <br>

## `TypeQuery, Query`

- TypeQuery: 반환 타입이 명확할 때 사용합니다.
- Query: 반환 타입이 명확하지 않을 때 사용합니다.

<br>

![스크린샷 2021-09-03 오전 6 22 36](https://user-images.githubusercontent.com/45676906/131918011-fb02df07-843f-4965-a423-85ea0919b629.png)

위의 코드를 보면 type1은 Member 전체를 가져오기 때문에 Member 타입으로 TypeQuery를 사용할 수 있고, type2는 username만 가져오기 때문에 String 타입으로 type2를 가져올 수 있습니다. type3는 username은 String이고 age는 int 이기 때문에 타입을 정할 수 없습니다. 그래서 이럴 때는 `Query`를 사용합니다.

<br> <br>

## `결과 조회`

![스크린샷 2021-09-03 오전 6 25 40](https://user-images.githubusercontent.com/45676906/131918340-a49d54b8-9e02-4b35-91f8-ac7e9e9d5554.png)

위와 같이 `getResultList()`를 사용하면 바로 `List<타입>` 형태로 가져올 수 있습니다.

<br>

![스크린샷 2021-09-03 오전 6 27 24](https://user-images.githubusercontent.com/45676906/131918535-566d32ed-01f0-4b32-b989-6155f14fa137.png)

그리고 `getSingleResult()`라는 메소드도 존재하는데 이것은 정확히 하나만 가져올 때 사용합니다. 이 메소드에는 주의할 점이 있습니다.

- `getSingleResult()`로 조회했을 때 `결과가 정확히 하나`여야 하는데, 결과가 없다면 `javax.persistence.NoResultException` 에러가 발생합니다.
- 둘 이상이면 `javax.persistence.NonUniqueResultException` 에러가 발생합니다.

<br> <br>

## `파라미터 바인딩`

바인딩은 `이름 기준`, `위치 기준`이 존재합니다.

<br>

### 이름 기준

![스크린샷 2021-09-03 오전 6 32 49](https://user-images.githubusercontent.com/45676906/131919134-e488fd78-421d-4c7e-a824-d99cbfefbd21.png)

<br>

![스크린샷 2021-09-03 오전 6 33 30](https://user-images.githubusercontent.com/45676906/131919188-fb80de36-f442-4c27-8629-0394b194a2a9.png)

위와 같이 username으로 제대로 바인딩이 잘 된 것을 볼 수 있습니다.

<br>

### 위치 기준

하나 추가되면 다 바꿔야 하기 때문에 위치 기준은 웬만하면 사용하지 않는 것이 좋습니다. 사용법은 `?1`을 사용하면 됩니다.

![스크린샷 2021-09-03 오전 6 35 48](https://user-images.githubusercontent.com/45676906/131919447-7a773a93-7102-4bc5-b116-63c5c04054fe.png)

<br> <br>

## `프로젝션`

SELECT 절에 조회할 대상을 지정하는 것을 `프로젝션`이라 하고, [SELECT {프로젝션 대상} FROM] 으로 대상을 선택합니다.

- SELECT m FROM Member m -> 엔티티 프로젝션
- SELECT m.team FROM Member m -> 엔티티 프로젝션
- SELECT m.address FROM Member m -> 임베디드 프로젝션 (Address는 Embedded 타입이어서)

<br>

![스크린샷 2021-09-09 오후 2 07 36](https://user-images.githubusercontent.com/45676906/132626183-704d0032-78fd-4055-a106-ac1c37cba579.png)

위와 같이 JPQL를 통해서 Member를 꺼냈을 때 이게 영속성 컨텍스트에서 관리가 되는지 확인해보겠습니다. 위에서 `em.flush()`, `em.clear()`를 통해서 영속성 컨텍스트를 비운 후에 JPQL로 다시 쿼리를 조회해보겠습니다. 
그리고 `setAge(20)`을 통해서 Member의 값이 바뀐다면 영속성 컨텍스트에서 관리되고 있는 것인데요. 실행해서 테스트를 해보겠습니다.

![스크린샷 2021-09-09 오후 2 10 52](https://user-images.githubusercontent.com/45676906/132626463-ca505eb6-f7b9-462d-b786-8687e16aa819.png)

<br>

<img width="228" alt="스크린샷 2021-09-09 오후 2 11 16" src="https://user-images.githubusercontent.com/45676906/132626488-237ac79a-bf46-4a33-b2be-1e7f0cadd365.png">

값도 20으로 바뀐 것을 확인할 수 있습니다. 

<br> <br>

## `프로젝션 - 여러 값 조회`

![스크린샷 2021-09-09 오후 2 21 02](https://user-images.githubusercontent.com/45676906/132627411-812f0deb-3ed0-4110-adf4-8e0b3b770dbd.png)

Object[]을 사용해서 위와 같이 여러 값을 조회할 수도 있습니다. 

<br>

### `NEW 명령어`

![스크린샷 2021-09-09 오후 2 25 32](https://user-images.githubusercontent.com/45676906/132627790-51157205-dbd3-4380-ad05-9e5b66d60771.png)

NEW 명령어 방식은 위와 같이 먼저 Dto를 만들겠습니다. 

<br>

![스크린샷 2021-09-09 오후 2 26 11](https://user-images.githubusercontent.com/45676906/132627886-2198b250-d625-43d1-8ae5-c708121a5a6c.png)

그리고 사용법은 위와 같이 사용하면 됩니다. 좀 더 깔끔한 느낌이 있지만, 이것 역시 new 와 함께 dto 패키지 명을 다 적어주어야 한다는 단점이 존재합니다. 

<br> <br>

## `페이징 API`

페이징 처리용 SQL을 작성하는 일은 지루하고 반복적입니다. 더 큰 문제는 데이터베이스마다 페이징을 처리하는 SQL 문법이 다르다는 점입니다. JPA는 페이징을 다음 두 API를 추상화해놓았습니다.

- `setFirstResult(int startPosition)`: 조회 시작 위치(0 부터 시작)
- `setMaxResults(int maxResult)`: 조회할 데이터 수

<br>

![스크린샷 2021-09-09 오후 2 36 28](https://user-images.githubusercontent.com/45676906/132628982-ee68dee1-8fc3-4fba-92ad-9795a888648e.png)

위와 같이 100명의 Member를 ISERT 한 후에 페이징 쿼리를 작성했을 때 어떻게 결과가 나오는지 실행해보겠습니다. 

<br>

![스크린샷 2021-09-09 오후 2 39 46](https://user-images.githubusercontent.com/45676906/132629222-e8be4a4d-de0b-4efc-821f-bf9e4f50eb9d.png)

그러면 위와 같이 100명 중에서 10개의 페이징을 처리해서 결과로 반환해준 것을 볼 수 있습니다. 

<br>

![스크린샷 2021-09-09 오후 2 42 08](https://user-images.githubusercontent.com/45676906/132629450-bdf9d8ce-8094-4055-948c-620169fd20eb.png)

만약에 방언을 Oracle로 바꾸게 되면 위와 같은 페이징 쿼리를 JPA가 만들어줍니다. 상당히 복잡한 것을 알 수 있는데요. 이러한 복잡한 쿼리를 JPA를 추상화 하여 쉽게 사용할 수 있도록 만들어놓았다는 장점이 있습니다.

<br>

![스크린샷 2021-09-09 오후 2 46 08](https://user-images.githubusercontent.com/45676906/132629847-ba31239b-7de2-4453-b05a-2f21180912d4.png)

그리고 MySQL 쿼리는 위와 같이 생성해줍니다. 이렇게 모든 DB 방언마다 쿼리가 다르다는 문제점도 JPA를 통해서 해결할 수 있습니다. 

<br> <br>

## `JPQL 조인`

### 내부 조인

```java
String query = "select m from Member m inner join m.team t";
List<Member> result = em.createQuery(query, Member.class)
        .getResultList();
```

위와 같이 SQL 문법과 비슷하긴 한데 다른 것을 볼 수 있습니다. Member가 Team을 참조하고 있기에 위와 같이 `inner join m.team`으로 `JOIN` 하는 것을 볼 수 있습니다.

<br>

### `외부 조인`

```java
String query = "select m from Member m outer left join m.team t";
List<Member> result = em.createQuery(query, Member.class)
        .getResultList();
```

외부 조인도 `outer`를 사용하면 됩니다. 

<br> <br>

## `JOIN ON 절`

JPA 2.1 부터 조인할 때 ON 절을 지원합니다. ON 절을 사용하면 조인 대상을 필터링 하고 조인할 수 있습니다. 

```java
// JPQL
SELECT m.t FFROM Member m LEFT JOIN m.team t on t.name = 'A'
```

```sql
--  SQL
SELECT m.*, t.*
FROM Membmer m 
LEFT JOIN Team t
ON m.team_id = t.id AND t.name = 'A'
```

그래서 실제로 JPQL에서 ON을 추가해서 JOIN을 해보겠습니다.

<br>

```java
String query = "select m from Member m left join m.team t on t.name = 'teamA'";
List<Member> result = em.createQuery(query, Member.class)
        .getResultList();
```

위와 같이 임의로 t.name에 `teamA`를 준 후에 실행해보겠습니다. 

<br>

![스크린샷 2021-09-09 오후 3 43 41](https://user-images.githubusercontent.com/45676906/132636137-9d8fb568-79e6-4d64-9567-57738348f584.png)

그러면 위와 같이 `LEFT OUTER JOIN`과 `ON`이 쿼리로 만들어진 것을 볼 수 있습ㄴ디ㅏ. 

<br> <br>

## `서브 쿼리`

JPQL도 SQL처럼 서브 쿼리를 지원합니다. 하지만 몇 가지 제약이 있는데, 서브 쿼리를 WHERE, HAVING 절에서만 사용할 수 있고 SELECT, FROM 절에서는 사용할 수 없습니다. 

<br>

### `나이가 평균보다 많은 회원`

```sql
SELECT m
FROM Member m
WHERE m.age > (SELECT avg(m2.age) FROM Member m2)
```

서브쿼리의 Member는 m2로 별칭을 주었고 위의 Member는 m으로 별칭을 준 것을 볼 수 있습니다. 이처럼 서로 관련이 없게 서브 쿼리를 작성해야 성능이 더 잘나옵니다. 

<br>

### `한 건이라도 주문한 고객`

```sql
SELECT m
FROM Member m
WHERE (SELECT COUNT(o) FROM Order o WHERE m = o.member) > 0
```

이번 쿼리는 Member의 별칭 m이 서브쿼리에서도 사용되는 것을 볼 수 있는데, 이러면 성능 이슈가 있을 수 있습니다. 

<br> <br>

## `서브 쿼리 함수`

### `EXISTS`

서브쿼리에 결과가 존재하면 참입니다. 

```sql
SELECT m FROM Member m
WHERE exists (SELECT t FROM m.team t WHERE t.name = '팀A')
```

<br>

### `IN`

```sql
SELECT t FROM Team t
WHERE t IN (SELECT t2 FROM Team t2 JOIN t2.members m2 WHERE m2.age >= 20)
```

서브쿼리의 결과 중 하나라도 같은 것이 있으면 참입니다. 

<br> <br>

## `JPA 서브 쿼리 한계`

- JPA는 WHERE, HAVING 절에서만 서브 쿼리 사용 가능
- 하이버네이트를 사용한다면 SELECT 절도 가능
- `FROM 절의 서브 쿼리는 현재 JPQL에서 불가능`

<br> <br>

## `JPQL 기본 함수`

