## `2. 간단한 프로토콜 HTTP`

TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버 간에 통신을 한다.

요청을 보내는 쪽을 `클라이언트`라고 하고, 요청을 받는 쪽을 `서버`라고 한다.

```
GET /index.html HTTP /1.1
Host: www.nvaer.com
```

요청 HTTP 형태를 보면 `HTTP GET`에 `HTTP 1.1` 방식을 사용하는 것을 볼 수 있고, `www.naver.com`에 `index.html` 리소스를 조회하는 요청을 네이버 서버로 보내는 것이다. 

```
POST /form/entry HTTP/1.1
(아래는 리퀘스트 헤더 필드)
Host: www.naver.com
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 16
```

좀 더 HTTP 메세지를 구체화하면 위와 같이 `HTTP Request Header` 정보들도 존재한다.

<br>

```
HTTP /1.1 200 OK
Date: Tue, 10 Jul 2022 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

<html> 
...

```

서버로 HTTP 요청이 들어오게 되면 위와 같은 HTTP 응답 값을 만들어서 클라이언트에게 반환을 해준다. 기본적으로 리스폰스 메세지는 프로토콜 버전, 상태 코드, 상태 코드를 설명하는 리스폰스 헤더와 필드 바디로 구성되어 있다.

<br>

## `HTTP는 상태를 유지하지 않는 프로토콜`

HTTP는 상태를 계속 유지하지 않는 `Stateless 프로토콜`이다. HTTP 프로토콜 독자적으로, 리퀘스트와 리스폰스를 교환하는 동안에 상태를 관리하지 않는다. 결국 HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억나지 않는다.

HTTP에서는 새로운 리퀘스트가 보내질 때 마다 새로운 리스폰스가 생성된다. 프로토콜로서는 과거의 리퀘스트나 리스폰스 정보를 전혀 가지고 있지 않다.

하지만 로그인 같은 정보는 상태를 유지할 필요가 있는데, HTTP/1.1은 상태를 유지하지 않는 프로토콜이다. 그래서 상태를 유지하고 싶은 요구에 부응하기 위해서 `쿠키(Cookie)` 라는 기술이 도입되었다.

<br>

## `서버에 임무를 부여하는 HTTP 메소드`

### `GET: 리소스 획득`

GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다. 

<br>

### `POST: 엔티티 전송`

POST 메소드는 Request Body를 통해서 데이터를 서버에게 전송할 수 있고, 서버의 리소스를 생성하거나 변화시킬 때 주로 사용하는 메소드이다.

<br>

### `PUT: 파일 전송`

`리소스를 완전히 대체한다.` 리소스가 서버에 있으면 대체하고 리소스가 서버에 없으면 생성한다.

<br>

### `HEAD: 메세지 헤더 취득`

HEAD 메소드는 GET과 같은 기능이지만 메세지 바디는 돌려주지 않는다. URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용된다.(HEAD 메소드는 첨 봄)

<br>

### `DELETE: 파일 삭제`

DELETE 메소드는 서버의 리소스를 삭제하기 위해 사용한다.

<br>

### `OPTIONS: 제공하고 있는 메소드의 문의`

OPTIONS 메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용한다. CORS 본 요청을 보내기 전에 Preflight Request를 보내는데 이 때 OPTIONS를 사용해서 요청을 보낸다.

<br>

## `지속 연결로 접속량을 절약`

HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었다. 초기에는 간단한 텍스트 정도를 전달하는 통신이었기에 문제가 없었지만, HTTP가 널리 보급된 이후에는 다량의 이미지를 포함한 문서들이 늘어났다.

여러 이미지가 포함되어 있는 HTTP 요청이라면 이미지를 획득하기 위해서 여러 리퀘스트를 송신한다. 그렇기 때문에 요청을 보낼 때마다 매번 TCP 연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 된다.

<br>

## `지속 연결`

HTTP/1.1와 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해서 `지속 연결`이라는 방법을 고안하였다. `지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.`

`지속 연결을 하는 이점은 TCP 커넥션의 연결과 종료를 반복하는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 줄어든다.` 또한 오버헤드를 줄인 만큼 HTTP 요청과 응답이 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있다. (이러한 지속 연결은 HTTP/1.1 에서는 표준 동작이지만 HTTP/1.0에서는 정식 사양은 아니었다.)

<br>

## `파이프라인화`

지속 연결은 여러 요청을 보낼 수 있도록 `파이프라인화`를 가능하게 한다. 파이프라인화에 의해서, 이전에는 요청을 받은 후에 응답을 줄 때까지 기다린 뒤에 요청을 보냈다면, 이제는 응답을 기다리지 않고 다음 요청을 보낼 수 있다.

<br>

## `쿠키를 사용한 상태 관리`

HTTP는 무상태 프로토콜이기에, 과거에 교환했던 요청, 응답 정보를 저장하지 않는다. 이렇게 무상태 프로토콜은 상태를 유지하지 않는다는 점에서 `서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다.`

하지만 무상태 프로토콜은 로그인 같은 기능을 유지할 수 없다면 단점이 있기 때문에 나온 개념이 바로 `쿠키`입니다. 

`쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다. 다음 번에 클라이언트가 같은 서버로 요청을 보낼 때, 자동으로 쿠키 값을 넣어서 송싱한다. 서버는 클라이언트가 보내온 쿠키를 학인해서 어느 클라이언트가 접속했는지 체크하여 작업을 수행한다.`

<br>

### `요청(쿠키를 가지고 있지 않은 상태)`

```
GET /reader /HTTP /1.1
Host: www.naver.com
* 헤더에 쿠키가 없다.
```

<br>

### `응답(서버가 쿠키를 발행)`

```
HTTP /1.1 200 OK
Date: Thu, 12 Jul 2022 07:12:20 GMT
Server: Apache
<Set-Cookie: sid=123123123131231; path=/;expireds=Web, => 10-Oct-12 07:12:20 GMT>
Content-Type: text/plain' charset=UTF-8
```

<br>

### `요청(보관하고 있던 쿠키를 자동 보냄)`

```
GET /image HTTP /1.1
Host: www.naver.com
Cookie: sid=123123123131231
```