## `B-Tree 인덱스를 통한 데이터 읽기`

어떤 경우에 인덱스를 사용하도록 유도할지, 또는 사용하지 못하게 할지 판단하려면 MySQL이 어떻게 인덱스를 이용해서 실제 레코드를 읽어 내는지 알아야합니다.(이것이 글을 쓰는 현재의 저에게는 너무나 쉽지 않지만..)
MySQL이 인덱스를 이용하는 대표적인 방법 3가지를 살펴보겠습니다.

<br>

### `인덱스 레인지 스캔`

`인덱스 레인지 스캔`은 인덱스의 접근 방법 가운데 갖아 대표적인 접근 방식입니다.

```sql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'GAD';
```

위의 쿼리가 실행될 때 어떠한 과정으로 실행이 될까요?

<br>

![스크린샷 2021-06-16 오전 9 32 22](https://user-images.githubusercontent.com/45676906/122140248-c241da80-ce85-11eb-848f-47328c0af7d5.png)

인덱스 레인지 스캔은 `검색해야 할 인덱스의 범위가 결정됐을 때 사용`하는 방식입니다.
즉, 원하는 결과를 찾으면 결과를 사용자에게 반환하고 쿼리를 끝냅니다.

<br>

![스크린샷 2021-06-16 오전 10 09 21](https://user-images.githubusercontent.com/45676906/122142685-ec49cb80-ce8a-11eb-8db3-20ddd493a4e1.png)

B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 특정 검색 시작 값을 가지고 있는 리프 노드를 검색하고, 그 지점부터 필요한 방향(오름차순 or 내림차순)으로 인덱스를 읽어 나가는 과정을 볼 수 있습니다.
`가장 중요한 것은 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다는 것`입니다.

또 하나 그림 5-10에서 중요한 것은 인덱스의 리포 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요한데요. 이 때 레코드 한 건 한 건 `랜덤 I/O`가 실행됩니다.
그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류되는 것입니다.

<br>

## `인덱스 풀 스캔`
