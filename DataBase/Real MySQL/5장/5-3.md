# `B-Tree 인덱스`

B-Tree 인덱스는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 또한 가장 먼저 도입된 알고리즘입니다. 
B는 Binary가 아니라 Balanced를 의미하는데요. B가 Binary 였다면 정~말 성능상 좋지 않았을텐데 왜 그런지 그 이유에 대해서도 차근 차근 알아보겠습니다.

<br>

## `B-Tree 구조 및 특성`

B-Tree 인덱스를 제대로 사용하려면 B-Tree의 기본적인 구조는 알고 있어야 합니다. 

![스크린샷 2021-06-15 오전 10 52 20](https://user-images.githubusercontent.com/45676906/121980925-c60f2780-cdc7-11eb-8bff-9a17dadb2886.png)

B-Tree의 구조는 위와 같습니다. 최상단에 `루트 노드` 그 하위에 자식 노드들이 존재하는데요. 중간에 존재하는 노드를 `브랜치 노드`라고 하고 마지막에 존재하는 노드를 `리프 노드`라고 합니다. 
인덱스의 리프노드는 `실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있습니다.`

<br>

<img width="483" alt="스크린샷 2021-06-15 오전 10 57 35" src="https://user-images.githubusercontent.com/45676906/121981377-80069380-cdc8-11eb-96e4-0828139ffb6a.png">

B-Tree의 리프 노드와 테이블 데이터 레코드는 위의 사진과 같은 관계를 가지고 있습니다. (InnoDB 테이블에서는 프라이머리 키에 의해 클러스터링되기 때문에 프라이머리 키 값 자체가 주소 역할을 합니다.)

<br>

## `B-Tree 인덱스 키 추가 및 삭제`

테이블의 레코드를 저장하거나 변경하는 경우, 인덱스 키 추가나 삭제 작업이 발생합니다. 인덱스 키 추가나 삭제가 어떻게 처리되는지 알아두면 쿼리의 성능을 쉽게 예측할 수 있을 것입니다. 
(하지만.. 저는 아직 쉽게 예측하기는 쉽지 않습니다,,)

<br>

## `인덱스 키 추가`


