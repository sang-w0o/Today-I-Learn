# `B-Tree 인덱스`

B-Tree 인덱스는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 또한 가장 먼저 도입된 알고리즘입니다. 
B는 Binary가 아니라 Balanced를 의미하는데요. B가 Binary 였다면 정~말 성능상 좋지 않았을텐데 왜 그런지 그 이유에 대해서도 차근 차근 알아보겠습니다.

<br>

## `B-Tree 구조 및 특성`

B-Tree 인덱스를 제대로 사용하려면 B-Tree의 기본적인 구조는 알고 있어야 합니다. 

![스크린샷 2021-06-15 오전 10 52 20](https://user-images.githubusercontent.com/45676906/121980925-c60f2780-cdc7-11eb-8bff-9a17dadb2886.png)

B-Tree의 구조는 위와 같습니다. 최상단에 `루트 노드` 그 하위에 자식 노드들이 존재하는데요. 중간에 존재하는 노드를 `브랜치 노드`라고 하고 마지막에 존재하는 노드를 `리프 노드`라고 합니다. 
인덱스의 리프노드는 `실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있습니다.`

<br>

<img width="483" alt="스크린샷 2021-06-15 오전 10 57 35" src="https://user-images.githubusercontent.com/45676906/121981377-80069380-cdc8-11eb-96e4-0828139ffb6a.png">

B-Tree의 리프 노드와 테이블 데이터 레코드는 위의 사진과 같은 관계를 가지고 있습니다. (InnoDB 테이블에서는 프라이머리 키에 의해 클러스터링되기 때문에 프라이머리 키 값 자체가 주소 역할을 합니다.)

<br>

## `인덱스 키 검색`

`INSERT`, `UPDATE`, `DELETE` 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 `빠른 검색`을 위해서 입니다. 
인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교하 작업을 수행합니다. (`트리 탐색`)

이러한 트리 탐색은 UPDATE, INSERT를 하기 위해 검색할 때도 사용됩니다. `B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우`에 사용할 수 있습니다. 

즉, 검색할 때 `Like %{keyword}%`로 쿼리를 구현하면 인덱스를 타지 않는 다는 것! (다른 검색 엔진(ex: ElasticSearch)을 쓰거나 그러지 않는다면 어쩔 수 없이 이렇게 검색 API를 구현하긴 해야 겠지만..)

<br>

## `B-Tree 인덱스 사용에 영향을 미치는 요소`

B-Tree 인덱스는 인덱스를 구성하는 `컬럼의 크기`, `레코드의 건수`, `유니크한 인덱스 키 값의 개수` 등에 의해 검색이나 변경 작업의 성능이 영향을 받습니다. 

<br>

### `인덱스 키 값의 크기`

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 `페이지` 라고 합니다.(디스크에 모든 읽기 ㅁ치 쓰기 작업의 최소 작업 단위)
B-Tree 그림에서 루트와 브랜치, 그리고 리프 노드를 구분한 기준이 페이지 단위입니다.

<br>

만약 B-Tree가 Binary-Tree 였다면 어떻게 될까요? 하나의 노드당 자식을 최대 2개만 가질 수 있어.. 데이터가 많아진다면 뎁스가 어마어마하게 깊어지게 될 것입니다. 
즉, 검색도 비효율적이게 될 것입니다. 

그래서 B는 Binary가 아니라 Balanced 인데요. 그러면 B-Tree는 자식 노드의 개수를 몇 개까지 가질 수 있을까요? 이것은 `인덱스 페이지 크기와 키 값의 크기에 따라 결정`됩니다. 

InnoDB의 모든 페이지 크기는 16KB로 고정되어 있습니다. 만약 인덱스 키가 16바이트라면 하나의 페이지에 대략 585개의 키를 저장할 수 있습니다. 

그러면 인덱스의 키 크기가 32바이트로 늘어났다면 어떻게 될까요? 한 페이지에 인덱스 키를 372개 저장할 수 있습니다. 만약 어떤 SELECT 쿼리로 레코드 500개를 읽어야 한다면 전자는 한번에 해결할 수 있지만, 후자는 최소한 2번 이상 디스크로부터 읽어야 합니다. 
결국 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미합니다. 

<br>

## `B-Tree 깊이`

Depth와 인덱스 키 값의 크기는 연관이 있습니다. 만약 depth=3, 키 값의 크기가 16KB 라면, 대략 2억개 정도 담을 수 있다고 하는데요.

그런데 키 값의 크기가 32KB 라면 5천만개로 줄어듭니다. 즉, `B-Tree 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제`입니다.

<br>

### `결론`

- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 작아지기 때문에 같은 레코드 건수라 하더라도 B-Tree(Depth)가 깊어져서 디크스 일기가 더 많이 필요하게 된다는 것을 의미합니다.

- 즉, 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋습니다. 

<br>

## `선택도(Cardinality)`






