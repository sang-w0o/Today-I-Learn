# `MySQL에서의 트랜잭션`

MySQL의 동시성에 영향을 미치는 `잠금(Lock)`, `트랜잭션`, 그리고 트랜잭션의 격리 수준을 살펴보겠습니다. `트랜잭션은 작업의 완전성을 보장해 주는 것`입니다. 

- `잠금`: 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능입니다.
- `트랜잭션`: 데이터의 정합성을 보장하기 위한 기능입니다. 

<br>

> 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
> <br> <br>
> 격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨

<br>

## `MySQL의 격리 수준`

트랜잭션의 `격리 수준(isolation level)`이란 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지르 결정하는 것입니다. 
격리 수준은 크게 아래와 같이 `4가지`로 나눌 수 있습니다.

- `READ UNCOMMITTED`
- `READ COMMITTED`
- `REPEATABLE READ`
- `SERIALIZABLE`

READ UNCOMMITTED 일반적인 데이터베이스에서는 거의 사용하지 않고, SERIALIZABLE 또한 동시성이 중요한 데이터베이스에서는 사용하지 않습니다. 4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지며,
동시에 동시성도 떨어지는 것이 일반적이라고 볼 수 있습니다. 

<br>

## `READ UNCOMMITTED`

![스크린샷 2021-05-25 오전 12 41 32](https://user-images.githubusercontent.com/45676906/119372146-f47e7300-bcf1-11eb-99b8-4c1f6dd96037.png)

`READ UNCOMMITTED` 격리 수준에서는 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여집니다.

위의 그림에서 보면, A 사용자가 INSERT 한 데이터가 COMMIT이 되기 전에 B 라는 사용자가 SELECT를 통해서 읽어오는 것을 볼 수 있습니다. 만약에 여기서 A 사용자가 INSERT 한 데이터가 롤백이 된다면 어떻게 될까요? 

그래도 여전히 B 사용자는 롤백 전의 데이터를 가지고 계속 처리할 것입니다. 이처럼 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상을 `더티 리드(Dirty read)`라고 합니다. 

즉, MySQL을 사용한다면 최소한 `READ COMMITTED` 이상의 격리 수준을 사용할 것을 권장합니다.

<br>

## `READ COMMITTED`

READ COMMITTED은 오라클 DBMS에서 기본적으로 사용되고 있는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준입니다. 
어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문입니다.

![스크린샷 2021-05-25 오전 12 56 01](https://user-images.githubusercontent.com/45676906/119373965-fa755380-bcf3-11eb-87c5-d4449975d31e.png)

사용자 A는 emp_no=500000 사원의 이름을 `Lara` -> `Toto`로 변경했는데, 이 때 새로운 값인 `Toto`는 employees 테이블에 즉시 기록되고 이전 값인 `Lara`는 언두 영역으로 백업됩니다.

사용자 A는 커밋을 수행하기 전에 사용자 B가 emp_no=500000인 사원을 SELECT 하면 조회된 결과의 first_name 컬럼의 값은 `Toto`가 아니라 `Lara`로 조회됩니다. 

`READ COMMITTED` 격리 수준에서는 어떤 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 그러한 변경 내역을 조회할 수 없기 때문입니다.
최종적으로 사용자 A가 변경된 내용을 커밋하면 그때부터는 다른 트랜잭션에서도 새롭게 변경된 값을 읽어올 수 있게 됩니다. 

<br>

### `NOT-REPEATABLE READ`

![스크린샷 2021-05-25 오전 1 08 48](https://user-images.githubusercontent.com/45676906/119375425-c3a03d00-bcf5-11eb-9aa8-a70d537a0968.png)

B가 BEGIN 명령으로 트랜잭션을 시작하고 first_name이 `Toto`인 사용자를 검색했는데 일치하는 사용자가 없었습니다. 하지만 A가 사원번호가 500000인 사원의 이름을 `Toto`로 변경하고 커밋을 실행한 이후
사용자 B가 다시 SELECT로 같은 사원을 조호하면 이번에는 `Toto`가 반환이 되는 것을 볼 수 있습니다. 

이는 사용자 B가 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 `REPEATABLE READ` 정합성에 어긋나는 것입니다. 

이러한 부정합 현상은 일반적인 상황에서는 크게 중요하지 않을 수 있지만 `금전적인` 처리와 연결되면 문제가 될 수도 있습니다. 

<br>

## `REPEATABLE READ`

REPEATABLE READ는 MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준입니다. MySQL과 InnoDB를 사용하는 제가 주의깊게 보아야할 것 같습니다. 
바이너리 로그를 가진 MySQL의 장비에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 합니다. 

InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경합니다. 이러한 변경 방식을 `MVCC`라고 합니다. 

`REPEATABLE READ는 이 MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장합니다.`







<br>

